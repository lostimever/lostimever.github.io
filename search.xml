<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一起学习、手写MVVM框架]]></title>
    <url>%2F2019%2F07%2F17%2Fmvvm%2F</url>
    <content type="text"><![CDATA[vue中的数据双向绑定，其实一句话就可以说清楚了：利用 Object.defineProperty()，并且把内部解耦为 Observer, Dep, 并使用 Watcher 相连。那根据这句话我们可以把整一个简单的MVVM框架粗分为以下四个模块：1.模板编译（Compile）2.数据劫持（Observer）3.订阅发布（Dep）4.观察者（Watcher）我们就根据这四个模块来分析、手写一个MVVM框架。想看源码的，请直接下滑到最后。 MVVM类和Vue类似，我们构建一个MVVM类，通过new指令创建一个MVVM实例，并传入一个类型为对象的参数option，包含当前实例的作用域el和模板绑定的数据data。 12345678910111213141516171819202122232425262728293031class MVVM &#123; constructor(options) &#123; // 挂载实例 this.$el = options.el; this.$data = options.data; // 编译模板 if(this.$el) &#123; // 数据劫持 把对象的所有属性 改成带set 和 get 方法的 new Observer(this.$data) // 将数据代理到实例上，直接操作实例即可，不需要通过vm.$data来进行操作 this.proxyData(this.$data) // 用数据和元素进行编译 new Compile(this.$el, this) &#125; &#125; proxyData(data) &#123; Object.keys(data).forEach(key =&gt; &#123; Object.defineProperty(this, key, &#123; get() &#123; return data[key] &#125;, set(newValue) &#123; data[key] = newValue &#125; &#125;) &#125;) &#125;&#125; MVVM类整合了所有的模块，作为连接Compile和Observer的桥梁。 模板编译（Compile）Compilecompile在编译模板的时候，其实是从指令和文本两个方面来处理的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class Compile &#123; constructor(el, vm) &#123; // 判断是否为DOM，若不是，自己获取 this.el = this.isElementNode(el) ? el : document.querySelector(el); this.vm = vm; if (this.el) &#123; // 1. 将真实DOM放进内存中 let fragment = this.node2fragment(this.el); // 2. 开始编译 提取想要的元素节点 v-model 和 文本节点 &#123;&#123;&#125;&#125; this.compile(fragment); // 3. 将编译好的 fragment 重新放回页面 this.el.appendChild(fragment); &#125; &#125; /** * 辅助方法 * 是否为元素节点 * @isElementNode * 是否为指令 * @isDirective */ isElementNode(node) &#123; return node.nodeType === 1; &#125; isDirective(name) &#123; return name.includes("v-"); &#125; /** * 核心方法 */ compileElement(node) &#123; // v-model v-text let attrs = node.attributes; // 取出当前节点的属性 Array.from(attrs).forEach(attr =&gt; &#123; let attrName = attr.name; if (this.isDirective(attrName)) &#123; // 判断属性名是否包含 v-model // 取到对应的值，放到节点中 let expr = attr.value; let [, type] = attrName.split("-"); //解构赋值v-model--&gt;model // 调用对应的编译方法， 编译哪个节点，用数据替换掉表达式 CompileUtil[type](node, this.vm, expr); &#125; &#125;); &#125; compileText(node) &#123; let expr = node.textContent; // 取出文本中的内容 let reg = /\&#123;\&#123;([^]+)\&#125;\&#125;/g; // &#123;&#123;a&#125;&#125; &#123;&#123;b&#125;&#125; &#123;&#123;c&#125;&#125; if (reg.test(expr)) &#123; // 调用编译文本的方法，编辑哪个节点，用数据替换掉表达式 CompileUtil["text"](node, this.vm, expr); &#125; &#125; // 递归 compile(fragment) &#123; let childNodes = fragment.childNodes; Array.from(childNodes).forEach(node =&gt; &#123; if (this.isElementNode(node)) &#123; // 如果是元素的节点，则继续深入检查 // 编译元素 this.compileElement(node); this.compile(node); &#125; else &#123; // 文本节点 // 编译文本 this.compileText(node); &#125; &#125;); // Array.from()方法是将一个类数组对象或者可遍历对象转换成一个真正的数组 &#125; // 将el中的内容全部放进内存中 node2fragment(el) &#123; // 文档碎片 内存中的 dom 节点 let fragment = document.createDocumentFragment(); let firstChild; // 把值赋给变量 取不到后返回null，null作为条件 while ((firstChild = el.firstChild)) &#123; // 使用appendChild() 方法从一个元素向另一个元素中移动 fragment.appendChild(firstChild); &#125; return fragment; // 内存中的节点 &#125;&#125; CompileUtilCompileUtil是一个对象工具，配合Copmpile使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115let CompileUtil = &#123; model(node, vm, expr) &#123; let updateFn = this.updater["modelUpdater"]; /** * * 这里应该加一个监控，数据变化了 应该调用watch的callback * (这里只是记录原始的值 watcher的update没有执行，只有属性的set执行的时候，才会执行cb回调，重新进行真实数据绑定) * */ new Watcher(vm, expr, newValue =&gt; &#123; // 当值变化后会调用cb 将新的值传递过来 updateFn &amp;&amp; updateFn(node, this.getVal(vm, expr)); &#125;); node.addEventListener("input", e =&gt; &#123; let newValue = e.target.value; //监听输入事件，将输入的内容设置到对应数据上 this.setVal(vm, expr, newValue); &#125;); updateFn &amp;&amp; updateFn(node, this.getVal(vm, expr)); &#125;, text(node, vm, expr) &#123; // 文本处理 let updateFn = this.updater["textUpdater"]; let value = this.getTextVal(vm, expr); expr.replace(/\&#123;\&#123;((?:.|\r?\n)+?)\&#125;\&#125;/g, (...args) =&gt; &#123; new Watcher(vm, args[1], newValue =&gt; &#123; // 如果数据变化了，文本节点需要重新获取依赖的属性，更新文本中的内容 updateFn &amp;&amp; updateFn(node, this.getTextVal(vm, expr)); &#125;); &#125;); updateFn &amp;&amp; updateFn(node, value); &#125;, getTextVal(vm, expr) &#123; // 获取编译文本后的结果 let value = this.parseText(expr); let result = ''; value.tokens.forEach((item) =&gt; &#123; if(item.hasOwnProperty('@binding')) &#123; result += this.getVal(vm, item['@binding']) &#125; else &#123; result += item &#125; &#125;) return result &#125;, parseText(text) &#123; const tagRE = /\&#123;\&#123;((?:.|\r?\n)+?)\&#125;\&#125;/g; if (!tagRE.test(text)) &#123; return; &#125; const tokens = []; const rawTokens = []; let lastIndex = (tagRE.lastIndex = 0); let match, index, tokenValue; while ((match = tagRE.exec(text))) &#123; index = match.index; // push text token if (index &gt; lastIndex) &#123; rawTokens.push((tokenValue = text.slice(lastIndex, index))); tokens.push(JSON.stringify(tokenValue)); &#125; // tag token const exp = match[1].trim(); tokens.push(`_s($&#123;exp&#125;)`); rawTokens.push(&#123; "@binding": exp &#125;); lastIndex = index + match[0].length; &#125; if (lastIndex &lt; text.length) &#123; rawTokens.push((tokenValue = text.slice(lastIndex))); tokens.push(JSON.stringify(tokenValue)); &#125; return &#123; expression: tokens.join("+"), tokens: rawTokens &#125;; &#125;, setVal(vm, expr, value) &#123; expr = expr.split("."); return expr.reduce((prev, next, currentIndex) =&gt; &#123; if (currentIndex === expr.length - 1) &#123; return (prev[next] = value); &#125; return prev[next]; &#125;, vm.$data); &#125;, getVal(vm, expr) &#123; // 获取实例上对应的数据 expr = expr.split("."); // &#123;&#123;message.a&#125;&#125; [message, a] // vm.$data.message =&gt; vm.$data.message.a return expr.reduce((prev, next) =&gt; &#123; return prev[next.trim()]; &#125;, vm.$data); /** * 关于 reduce： * arr.reduce(callback,[initialValue]) */ &#125;, updater: &#123; // 文本更新 textUpdater(node, value) &#123; node.textContent = value; &#125;, // 输入框更新 modelUpdater(node, value) &#123; node.value = value; &#125; &#125;&#125;; 再次认识到正则表达式的重要性。在处理`{{}}`模板引擎的时候，遇到一个bug，在一个DOM节点里，如果有个有多个`{{}}{{}}`会显示为undefined，后来仔细阅读了vueJs的源码，借鉴其中parseText()方法，进行处理，得以解决。 数据劫持（Observer）什么是数据劫持？在访问或修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作，或者修改返回的结果。 数据劫持的作用是什么？它是双向数据绑定的核心方法，通过劫持对象属性的setter和getter操作，监听数据的变化，同时也是后期ES6中很多语法糖底层实现的核心方法。 使用Object.defineProperty()做数据劫持，有什么弊端？1、不能监听数组的变化2、必须遍历对象的每个属性3、必须深层遍历嵌套的对象 MVVM中的数据劫持123456789101112131415161718192021222324252627282930313233343536373839404142434445class Observer &#123; constructor(data) &#123; this.observe(data) &#125; observe(data) &#123; // 要对这个data数据，将原有的属性改成set和get的形式 // defineProperty针对的是对象 if(!data || typeof data !== 'object') &#123; return &#125; // 将数据一一劫持，先获取到data的key和value Object.keys(data).forEach(key =&gt; &#123; // 定义响应式变化 this.defineReactive(data, key, data[key]) this.observe(data[key]) //深度递归劫持 &#125;) // 关于Object.keys() 返回一个包含对象的属性名称的数组 &#125; // 定义响应式 defineReactive(obj, key, value) &#123; let that = this; let dep = new Dep(); // 每个变化的数据 都会对应一个数组，这个数组是存放所有更新的操作 Object.defineProperty(obj, key, &#123; enumerable: true, // 是否能在for...in循环中遍历出来或在Object.keys中列举出来 configurable: true, // false，不可修改、删除目标属性或修改属性性以下特性 get() &#123; Dep.target &amp;&amp; dep.addSub(Dep.target) return value; &#125;, set(newValue) &#123; if(newValue != value) &#123; that.observe(newValue); // 如果设置的是对象，继续劫持 value = newValue; dep.notify(); //通知所有人 数据更新了 &#125; &#125; &#125;) &#125;&#125; 订阅发布（Dep）其实发布订阅说白了就是把要执行的函数统一存储在一个数组subs中管理，当达到某个执行条件时，循环这个数组并执行每一个成员。 12345678910111213141516class Dep &#123; constructor() &#123; // 订阅数组 this.subs = []; &#125; // 添加订阅 addSub(watcher) &#123; this.subs.push(watcher); &#125; // 将消息通知给所有人 notify() &#123; this.subs.forEach(watcher =&gt; watcher.update()); &#125;&#125; 观察者（Watcher）Watcher 类的作用是，获取更改前的值存储起来，并创建一个 update 实例方法，当值被更改时，执行实例的 callback 以达到视图的更新。 1234567891011121314151617181920212223242526272829303132333435class Watcher&#123; // 因为要获取 oldValue，所以需要“数据”和“表达式” constructor(vm, expr, cb) &#123; this.vm = vm; this.expr = expr; this.cb = cb; // 先获取 oldValue 保存下来 this.value = this.get(); &#125; getVal(vm, expr) &#123; expr = expr.split('.'); return expr.reduce((prev, next) =&gt; &#123; return prev[next.trim()] &#125;, vm.$data); &#125; get() &#123; // 在取值之前先将 watcher 保存到 Dep 上 Dep.target = this; let value = this.getVal(this.vm, this.expr); Dep.target = null; return value; &#125; // 对外暴露的方法，如果值改变就可以调用这个方法来更新 update() &#123; let newValue = this.getVal(this.vm, this.expr); let oldValue = this.value; if (newValue != oldValue) &#123; this.cb(newValue); &#125; &#125;&#125; 最后最后当然是要检测一下，我们的写的代码是不是能正常运行。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;!-- 双向数据绑定 靠的是表单 --&gt; &lt;input type="text" v-model="message.a" /&gt; &lt;div&gt;&#123;&#123; message.a &#125;&#125; 啦啦啦&lt;/div&gt; &#123;&#123; message.a &#125;&#125; &#123;&#123; b &#125;&#125; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script src="observer.js"&gt;&lt;/script&gt;&lt;script src="watcher.js"&gt;&lt;/script&gt;&lt;script src="compile.js"&gt;&lt;/script&gt;&lt;script src="dep.js"&gt;&lt;/script&gt;&lt;script src="mvvm.js"&gt;&lt;/script&gt;&lt;script&gt; let vm = new MVVM(&#123; el: "#app", data: &#123; message: &#123; a: "wlf" &#125;, b: "biubiubiu" &#125; &#125;);&lt;/script&gt; 总结我们根据下图（参考《深入浅出vue.js》），将整个流程再梳理一遍： 在 new MVVM() 后， MVVM 会进行初始化即实例化MVVM，在这个过程中，模板绑定的数据data通过Observer数据劫持，转换成了getter/setter的形式，来监听数据的变化，当被设置的对象被读取的时候会执行getter函数，当它被赋值的时候会执行setter函数。 当页面渲染的时候，会读取所需对象的值，这个时候会触发getter函数从而将Watcher添加到Dep中进行依赖收集，添加订阅。 当对象的值发生变化时，会触发对应的setter函数，setter会调用dep.notify()通知之前依赖收集得到的 Dep 中的每一个 Watcher，也就是遍历subs这个数组，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher就会开始调用 update() 来更新视图。 贴出源码地址：https://github.com/lostimever/MVVM]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 中什么样的继承才是好的继承？]]></title>
    <url>%2F2019%2F07%2F09%2Fjavascriptinherit%2F</url>
    <content type="text"><![CDATA[前言理解对象和继承是我们学习设计模式，甚至是阅读各种框架源码的第一步。上一篇文章，笔者已经把JavaScript对象进行了梳理，今天我们来一起学习继承。 继承原型链基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法，也就是将一个原型对象指向另一个引用类型的实例。Example: 1234567891011121314function Parent() &#123; this.property = true&#125;Parent.prototype.getParentValue = () =&gt; this.propertyfunction Child() &#123; this.childProperty = false&#125;Child.prototype = new Parent()Child.prototype.getChildValue = () =&gt; this.childPropertylet instance = new Child()console.log(instance.getParentValue()) // true Child 通过创建 Parent 实例，并将实例赋值给 Child.prototype 的方式，继承了 Parent 。本质是利用实例重写了原型对象。这样，Child.prototype 拥有了 Parent 的全部属性和方法，同时其内部指针也指向了 Parent.prototype 。通过实现原型链，本质上拓展了原型搜索机制。 添加方法（谨慎）：字类型有时需要重写超类型中的某个方法，或新增超类型中不存在的方法，一定要将给原型添加方法的代码放在被替换原型的语句后面。Example： 123456789101112131415161718192021function Parent() &#123; this.property = true; &#125;Parent.prototype.getParentValue = () =&gt; this.propertyfunction Child() &#123; this.childProperty = false; &#125;//继承了 SuperType Child.prototype = new Parent();//添加新方法 Child.prototype.getChildValue = () =&gt; this.childProperty//重写超类型中的方法 Child.prototype.getParentValue = () =&gt; falselet instance = new ChildType(); console.log(instance.getParentValue()); //false 原型链继承存在的问题： 创建子类型实例时，不能向父类的构造函数中传递参数 父子构造函数的原型对象之间存在共享问题example： 123456789101112function Parent()&#123; this.colors = ["red", "blue", "green"];&#125;function Child() &#123;&#125;Child.prototype = new Parent();let instanceChild = new Child();instance1.colors.push("black");console.log(instanceChild.colors); //"red", "blue", "green","black"//当我们改变colors的时候, 父构造函数的原型对象的也会变化let instanceParent = new Parent();console.log(instanceParent.colors); //"red", "blue", "green","black" 构造函数基本思想：在子类构造函数的内部，调用父类的构造函数Example: 12345678910111213141516function Parent(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;function Child() &#123; Parent.call(this, "jerry"); // 继承了 Parent this.age = 22;&#125;let instanceChild = new Child();instanceChild.colors.push("black");console.log(instanceChild.name); // jerryconsole.log(instanceChild.colors); //"red", "blue", "green","black"let instanceParent = new Parent();console.log(instanceParent.colors); //"red", "blue", "green" 构造函数问题： 方法都在构造函数中定义，因此函数很难复用 在父类原型对象中定义的方法，子类无法继承 组合继承简单的说：原型链+构造函数基本思想：原型链实现对原型属性和方法的继承，构造函数实现对实例属性的继承Example： 123456789101112131415161718192021function Parent(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;Parent.prototype.sayName = () =&gt; &#123; console.log(this.name) &#125;function Child(name, age) &#123; Parent.call(this, name); // 继承属性 this.age = age;&#125;// 继承方法Child.prototype = new Parent();Child.prototype.constructor = Child;Child.prototype.sayAge = () =&gt; &#123; console.log(this.age) &#125;let instanceChild = new Child("jerry", 23);instanceChild.colors.push("black"); console.log(instanceChild.colors); //"red", "blue", "green","black"instanceChild.sayName(); // jerryinstanceChild.sayAge(); // 23 存在问题： 若再添加一个子类型，给其原型单独添加一个方法，那么其他子类型也同时拥有了这个方法，因为它们都指向同一个父类型的原型 无论在什么情况下都会调用两次父类的构造函数，我们不得不在调用子类构造函数时，重写这些属性。 原型式继承基本思想： 本质是对继承对象执行了一次浅拷贝。example： 1234567891011121314151617181920function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;// ES5内置了object.create()方法可以以上方法的功能。let parent = &#123; name: "jerry", friends: ["marry", "sandy"]&#125;let Child1 = object(parent);Child1.name = "barbie";Child1.friends.push("Rob");let Child2 = object(parent);Child2.name = "Cos";Child2.friends.push("Linda");console.log(parent.friends); //"marry", "sandy","Rob","Linda" 存在问题： 与原型链继承一样，父子对象之间存在共享问题 无法实现复用 寄生式继承基本思路：在原型式继承外面套了一层函数，在该函数内部增强对象。 123456789101112function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;// 壳子function createAnother(original) &#123; let clone = object(original); clone.sayHi = () =&gt; &#123; console.log("Hi") &#125; return clone;&#125; 存在问题： 复用率贼低 寄生组合式继承基本思想： 利用构造函数来继承属性，利用原型链的混成形式来继承方法。example: 12345678910111213141516171819202122232425function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function inheritPrototype(child, parent) &#123; let prototype = object(parent.prototype) prototype.constructor = child; child.prototype = prototype;&#125;function Parent(name) &#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;Parent.prototype.sayName = () =&gt; &#123; console.log(this.name) &#125;function Child(name, age) &#123; Parent.call(this, name); // 继承属性 this.age = age;&#125;inheritPrototype(Child, Parent)Child.prototype.sayAge = () =&gt; this.age 目前来说，这是最好的继承方式。 结束懒癌发作，明明早就写好了，一直把他丢弃在电脑硬盘里。几周之后，我挣扎着打开MWeb，稍做修葺，赶个结束语。算是画上一个句号吧。最后，不得不说，高级3，真是一本不可多得的好书，把对象、继承讲得如此清晰明了。 参考 《JavaScript高级程序设计》第3版]]></content>
  </entry>
  <entry>
    <title><![CDATA[你对JavaScript面向对象了解多少？]]></title>
    <url>%2F2019%2F06%2F13%2F%E5%88%9B%E5%BB%BAJavaScript%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[前言前两天看到一个有意思的观点：工具的进步，不代表你能力的进步。前端框架风起云涌，我们用得得心应手，回过头来，脱离框架我们还剩下什么？我觉得这是个值得深思的问题。扯远了，本文主要是想把JavaScript中面向对象的知识做一个整理和回顾，加深印象。 怎怎怎么找对象？new 一个对象没有对象怎么办？new 一个！（单身汪哭晕在厕所） 123456let obj = new Object();obj.name = 'object';obj.value = 11;obj.methods = function() &#123; console.log('this is a object')&#125;; 这便是创建一个对象最简单的方式。但是，每次都要 new 一个，复杂又麻烦，有没有更简单的方式呢？往下看 使用字面量创建what？啥是字面量？字面量：literals，有些书上叫做直接量。看见什么，它就是什么举个栗子： 1234567let obj = &#123; name : 'object'; value : 11; methods : function() &#123; console.log('this is a object') &#125;;&#125;; 简单粗暴？！事实上，如果是简单的创建几个对象，使用字面量创建对象无可厚非，但若有很多相似对象需要创建，这种方式便会产生大量的重复代码，显然这是很不友好的。于是工厂模式应运而生。 工厂模式123456789101112function createFactory(name, value) &#123; let obj = new Object(); obj.name = name; obj.value = value; obj.methods = function() &#123; console.log('this is a object, my name is ' + this.name) &#125;; return obj;&#125;let createFactory1 = factory('saints', 12)let createFactory2 = factory('Google', 50) 工厂模式虽然解决了创建 多个相似对象的问题，但却没有解决对象识别的问题，也就是说，无法区分它们的对象类型。这该怎么办呢？ 构造函数模式先用构造函数模式重写上面的例子： 12345678910function Factory(name, value) &#123; this.name = name; this.value = value; this.methods = function() &#123; console.log('this is a object, my name is ' + this.name) &#125;;&#125;let factory1 = new Factory('saints', 12);let factory2 = new Factory('Google', 50); 这里我们使用一个大写字母F开头的构造函数替代了上例中的createFactory，注意按照约定构造函数的首字母要大写。它和工厂模式有什么区别？ 没有显示的创建对象 直接将属性和方法赋值给了this对象 没有return语句 创建 Factory 实例时，必须使用new操作符 构造函数大法好啊，只不过它也不是万能的，最大的问题是，它的每个方法都要在每个实例上重新创建一次。换句话说，两个实例中调用的构造函数中的method方法不是同一个Function实例：console.log(factory1.method === factory2.method) // false为啥会这样呢？不要忘了，ECMAScript 中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。我们可以把 123this.methods = function() &#123; console.log('this is a object, my name is ' + this.name)&#125;; 看成： 123this.methods = new Function() &#123; console.log('this is a object, my name is ' + this.name)&#125;; 这样看是不是更加清楚了呢？调用同一个方法，却声明了不同的实例，实在浪费资源。大可像下面这样，通过把函数定义转移到构造函数外部来解决这个问题。 123456789101112function Factory(name, value) &#123; this.name = name; this.value = value; this.methods = methods&#125;function methods() &#123; console.log('this is a object, my name is ' + this.name)&#125;let factory1 = new Factory('saints', 12);let factory2 = new Factory('Google', 50); 堪称完美。But！！！ 我为要要在全局作用域中定义一个，只能被某个对象调用的函数呢？ 如果，这个对象有多个方法，那我得在全局作用域中定于多个函数。。。这让我们如何去优（zhuang）雅（bi）的封装一个对象呢？ 好在， 这些问题可以通过使用原型模式来解决。 原型模式我们每创建一个函数，都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象。也就是说，prototype 就是，通过调用构造函数创建的那个对象实例的原型对象。看到这我已经晕了。使用原型对象的好处是：可以让所有对象实例共享它所包含的属性和方法。上代码！ 12345678910111213function Factory() &#123; &#125;Factory.prototype.name = 'saints';Factory.prototype.value = 12;Factory.prototype.methods = function() &#123; console.log('this is a object, my name is ' + this.name)&#125;let factory1 = new Factory();factory1.methods(); // this is a object, my name is saintslet factory2 = new Factory();factory2.methods(); // this is a object, my name is saintsconsole.log(factory1.methods === factory2.methods) // true 这样就完美的解决了属性和方法共享的问题，所有的实例共享同一组属性和方法。 我们要知其然，还要知其所以然，原型模式的原理是什么呢？通过下面的流程图，一目了然： 在默认情况下，所有原型对象都会自动获得一个 constructor (构造函数)属性，这个属性包含一个指向 prototype 属性所在函数的指针，图中，Factory.prototype 指向了原型对象，而 Factory.prototype.constructor 又指回了 Factory 每当代码读取某个对象的某个属性时，都会执行一次搜索，首先会询问实例对象中有没有该属性，如果没有则继续查找原型对象（这就是执行期上下文） 123456let factory1 = new Factory();factory1.name = 'google'let factory2 = new Factory(); console.log(factory1.name); // googleconsole.log(factory2.name); // saints 当为对象实例添加一个属性时， 这个属性屏蔽原型对象中的同名属性，注意是屏蔽，这只会阻止我们去访问这个同名属性，而不会对它做修改。即使将该属性修改为null，也不会恢复我们对原型对象中同名属性的访问，除非使用delete彻底删除该属性。 大家可以看到，每次新增一个属性，都要输入一次Factory.prototype，为了减少不必要的输入，同时更加直观的封装原型对象的功能，我们使用字面量来重写整个原型对象： 12345678function Factory() &#123;&#125;Factory.prototype = &#123; name : 'saints'; value : 12; methods : function() &#123; console.log('this is a object, my name is ' + this.name) &#125;&#125; 有个地方需要注意的是，以对象字面量形式创建的新对象，本质上完全重写了默认的 prototype 对象，因此，此时的Factory.prototype.constructor已不再指向Factory，而是指向了Object。 123let factory1 = new Factory();console.log(factory1.constructor == Factory); //falseconsole.log(factory1.constructor == Object); //true 一般情况下，这种改变不会对我们造成困扰，如果 constructor 的值真的很重要，可以像下面这样特意将它设置回适当的值： 123456789101112function Factory() &#123;&#125;Factory.prototype = &#123; constructor: Factory, name : 'saints'; value : 12; methods : function() &#123; console.log('this is a object, my name is ' + this.name) &#125;&#125;let factory1 = new Factory();console.log(factory1.constructor == Factory); //true 你以为这样就完了么？too young too simple！来谈谈这种方式有哪些问题： 不能给构造函数传递初始化参数，因此，所有实例在默认情况下都将取得相同的属性值。 共享问题 假如原型的属性中包含引用类型，在实例中修改该属性的值，那么，其他实例中对应的属性的值，也会被修改。 因此开发者很少单独使用这种方式来创建对象。 组合使用构造函数模式和原型模式在实际开发过程中，我们使用构造函数模式来定义实例属性，而原型模式用于定义方法和共享的属性： 12345678910111213function Factory(name, value) &#123; this.name = name; this.value = value;&#125;Factory.prototype = &#123; constructor: Factory, methods : function() &#123; console.log('this is a object, my name is ' + this.name) &#125;&#125;let factory1 = new Factory('saints', 22);console.log(factory1.constructor == Factory); //true 每个实例都会有自己的一份实例属性，但同时又共享着方法，最大限度的节省了内存，还支持传递初始参数，优点甚多。在ECMAScript中是使用最广泛、认同度最高的一种创建自定义对象的方法。 动态原型模式动态原型模式，把所有信息都封装在了构造函数中，在构造函数中初始化原型(仅在必要的情况下)，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。 1234567891011function Factory(name, value) &#123; this.name = name; this.value = value; if (typeof this.methods == 'function') &#123; Factory.prototype.methods = function() &#123; console.log('this is a object, my name is ' + this.name) &#125; &#125;&#125;let factory1 = new Factory('saints', 22); Factory是一个构造函数，通过new Factory(…)来生成实例对象。每当一个Factory的对象生成时，Factory内部的代码都会被调用一次。 如果去掉if的话，每new一次(即每当一个实例对象生产时)，都会重新定义一个新的函数，然后挂到Factory.prototype.methods属性上。而实际上，你只需要定义一次就够了，因为所有实例都会共享此属性的。所以如果去掉if的话，会造成没必要的时间和空间浪费；而加上if后，只在new第一个实例时才会定义methods方法，之后就不会了。 假设除了methods方法外，你还定义了很多其他方法，比如sayBye、cry、smile等等。此时你只需要把它们都放到对methods判断的if块里面就可以了。 123456if (typeof this.methods != "function") &#123; Factory.prototype.methods = function() &#123;...&#125;; Factory.prototype.sayBye = function() &#123;...&#125;; Factory.prototype.cry = function() &#123;...&#125;; ...&#125; 万恶的面试题使用 new 操作符，经历了哪些步骤 创建一个新的对象； 将构造函数的作用域赋给新的对象（因此，this就指向了新的对象）； 执行构造函数中的代码（为这个新对象添加属性）； 返回新的对象。 构造函数和普通函数的区别构造函数和其他函数的唯一区别，就在于调用他们的方式不同。任何函数，只要是 通过 new 操作符来调用，那它就可以作为构造函数；任何函数，如果不通过 new 操作符来调用，那它和普通的函数没什么两样。 原型对象的问题 不能给构造函数传递初始化参数，因此，所有实例在默认情况下都将取得相同的属性值。 共享问题 假如原型的属性中包含引用类型，在实例中修改该属性的值，那么，其他实例中对应的属性的值，也会被修改。 结束终终于整理完毕，感觉每次更新都像是难产。不过感觉自己又回到了两年前，初识js，拿着红宝书迷茫的啃。现在依旧迷茫，只是在迷茫的路上，坚定了一点。 本文也收录在个人博客上lostimever.github.io。 参考 《JavaScript高级程序设计》第3版]]></content>
  </entry>
  <entry>
    <title><![CDATA[echarts各项配置]]></title>
    <url>%2F2019%2F06%2F06%2Fecharts%E5%90%84%E9%A1%B9%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[基于版本v4.x 前言吐血整理。Echarts的各种配置真的是眼花缭乱，第一次使用的时候，内心真的是崩溃啊，看到就害怕。最近开始搞项目了，面对一堆图表，更是无所适从，才萌生了整理echarts配置的想法。仅仅整理了常用的，后续如果有需求，会进行补充。 各项配置title（包含主标题和副标题）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152title: &#123; target: 'blank', // 指定窗口打开主标题超链接 // 'self'当前窗口打开 // 'blank'新窗口打开[default] textStyle: &#123; // 主标题文字样式 color: '#333', fontStyle: 'normal', // 字体风格 fontWeight: normal, // 粗细 fontFamily: 'sans-serif', // 字体 fontSize: 18, lineHeight: 56, // 行高 textBorderColor: 'transparent', // 文字本身的描边颜色 textBorderWidth: 0, // 文字本身的描边宽度 textShadowColor: 'transparent', // 文字本身的阴影颜色 textShadowBlur: 0, // 文字本身的阴影长度 textShadowOffsetX: 0, // 文字本身的阴影X偏移 textShadowOffsetY: 0, // 文字本身的阴影Y偏移 &#125;, subtextStyle: &#123; // 副标题样式 align: 'auto', // 文字水平对齐方式 left ¦ center ¦ right verticalAlign: 'auto', // 文字垂直对齐方式 top ¦ middle ¦ bottom &#125;, textAlign: 'auto', // 整体（主副标题）的水平对齐 textVerticalAlign: 'auto', // 整体（主副标题）的垂直对齐 triggerEvent: false, // 是否触发事件 padding: 5, // 标题内边距，单位px，默认各方向内边距为5， // 接受`数组`分别设定上右下左边距，同css itemGap: 10, // 主副标题间距 zlevel: 0, // 用于Canvas分层，内存开销大，谨慎使用 z: 2, // 控制图形的先后顺序，优先级低于zlevel x: 'left', // 水平安放位置，默认为左对齐，可选为： // center ¦ left ¦ right ¦ 像素值 y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // top ¦ bottom ¦ center ¦ 像素值 left: 'auto', // grid 组件容器左侧的距离 // center ¦ left ¦ right ¦ 像素值 ¦ % top: 'auto', // grid 组件容器上侧的距离 // top ¦ middle ¦ bottom ¦ 像素值 ¦ % right: 'auto', // grid 组件容器右侧的距离 // 像素值 ¦ % bottom: 'auto', // grid 组件容器下侧的距离 // 像素值 ¦ % backgroundColor: 'transparent', // 标题背景色 borderColor: '#ccc', // 标题边框颜色 borderWidth: 0, // 标题边框线宽 borderRadius: 0, // 圆角半径 单位px // 接受`数组`分别指定4个圆角半径 shadowBlur: ..., // 图形阴影的模糊大小 shadowColor: ..., // 阴影颜色 shadowOffsetX: 0, // 阴影水平方向上的偏移距离 shadowOffsetY: 0 // 阴影垂直方向上的偏移距离&#125; legend（图例）仅列出图例单独的属性，公共属性如：show、zlevel、x、y、z、left、top、right、bottom、padding、itemGap、backgroundColor、borderColor、borderWidth、borderRadius、shadowBlur、shadowColor、shadowOffsetX、shadowOffsetY以及textStyle中的部分属性，请参考title内容。 123456789101112131415161718192021222324252627282930313233343536373839404142legend: &#123; type: 'plain', // 图例类型： // 'plain'：普通图例；'scroll'：可滚动翻页图例 orient: 'horizontal', // 图例列表的布局朝向：horizontal | vertocal align: 'auto', // 图例标记和文本的对齐：auto | left | right itemWidth: 25, // 图例标记的图形宽度 itemHeight: 14, // 图例标记的图形高度 symbolKeepAspect: true, // 自定义图标时，是否在缩放时保持缩放比 formatter: null, // 格式化图例文本，支持字符串模板和回调函数 selectedMode: true, // 图例选择模式： // 是否可以通过点击图例，改变图表显示状态 inactiveColor: '#ccc', // 图例关闭时的颜色 selected: &#123; // 图例选中状态表 '系列1': true, // 选中'系列1' '系列2': false // 不选中'系列2' &#125;, textStyle: &#123;&#125;, // 图例的公用文本样式，公共样式请参考 `title` tooltip: &#123;...&#125;, // 同tooltip data: [&#123; name: ..., // 图例项的名称，应等于某系列的name值 icon: ..., textStyle: &#123;...&#125;, // 图例的文本样式(single) &#125;], // 以下属性，type为'scroll'时，有效 scrollDataIndex: 0, // 图例当前最左上显示项的`dataIndex` pageButtonItemGap: 5, // 图例控制块中，按钮和页信息之间的间隔 pageButtonGap: null, // 图例控制块和图例之间的间隔 pageButtonPosition: 'end', // 图例控制块的位置： // 'start'：控制块在左或上 // 'end'：控制块在右或下 pageFormatter: '&#123;current&#125;/&#123;total&#125;', // 页信息的显示格式 pageIcons: &#123; horizontal: [...], // orient为'horizontal'时的翻页按钮图标 vertical: [...] // orient为'vertical'时的翻页按钮图标 &#125;, pageIconColor: '#2f4554', // 翻页按钮颜色 pageIconInactiveColor: '#aaa', // 翻页按钮不激活时的颜色 pageIconSize: 15, // 翻页按钮的大小，接受数组、数字 pageTextStyle: &#123;...&#125;, // 图例页信息的文字样式 animation: ..., // 图例翻页是否使用动画 animationDurationUpdate: 800, // 图例翻页时的动画时常&#125; grid（网格）12345678910111213141516171819grid: &#123; show: false, // 是否显示直角坐标系网格 zlevel: 0, z: 2, left: '10%', top: 60, right: '10%', bottom: 60, width: 'auto', height: 'auto', containLabel: false, // grid 区域是否包含坐标轴的刻度标签 backgroundColor: 'transparent', borderColor: '#ccc', borderWidth: 1, shadowBlur: ..., shadowColor: ..., shadowOffsetX: 0, shadowOffsetY: 0,&#125; categoryAxis（类目轴）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475categoryAxis: &#123; show: true, // 是否显示 x 轴 gridIndex: 0, // x轴所在的grid的索引 position: ..., // x轴的位置 'top'|'bootom' offset: 0, // x轴相对于默认位置的偏移 // **在相同的`position`上有多个x轴的时候起作用** name: ..., // 坐标轴名称 nameLocation: 'end', // 坐标轴名称显示位置 // 'start'|'middle'或'center'|'end' nameTextStyle: &#123;...&#125;, // 坐标轴名称的文字样式 nameGap: 15, // 坐标轴名称与轴线之间的距离 nameRotate: null, // 坐标轴名字旋转，角度值 inverse: false, // 是否反向坐标轴 boundaryGap: ..., // 坐标轴两边留白 // 类目轴 'true'|'false' // 非类目轴 数组["20%", "20%"]，数组值可以为百分比或数值 min: null, /** 坐标轴刻度最小值 可以设置成特殊值 'dataMin'，此时取数据在该轴上的最小值作为最小刻度。 当设置成 function 形式时，可以根据计算得出数据的最小值来设定坐标轴的最小值 **/ max: null, // 坐标轴刻度最大值 同理 最小值 scale: false, // 数值轴有效，是否脱离0值比例 splitNumber: 5, // 坐标轴分割段数（预估值）类目轴无效 minInterval: 0, // 自动计算坐标轴最小间隔 设置成1保证坐标轴分割刻度显示成整数 maxInterval: ..., // 自动计算坐标轴最大间隔 interval: ..., // 强制设置坐标轴分割间隔 logBase: 10, // 对数轴的底数，只在对数轴中（type: 'log'）有效 silent: false, // 坐标轴是否是静态无法交互 triggerEvent: false, // 坐标轴的标签是否响应和触发鼠标事件，默认不响应 axisLine: &#123; // 坐标轴轴线相关设置 show: true, // 是否显示坐标轴轴线 onZero: true, // X轴或Y轴的轴线是否在另一个轴的'0'刻度上，只有在另一个轴为数值轴且包含'0'刻度时有效 onZeroAxisIndex: ..., // 当有双轴时，指定在哪个轴的'0'刻度上 symbol: 'none', // 轴线两边的箭头 ['none', 'arrow'] symbolSize: [10, 15], // 轴线两边的箭头的大小，['垂直','水平'] symbolOffset: [0, 0], // 轴线两边的箭头的偏移 &#125;, axisTick: &#123; // 坐标轴刻度相关设置 show: true, alignWithLabel: false, // 类目轴中'boundaryGap'为'true'时有效，保证刻度线和标签对齐 interval: 'auto', // 坐标轴刻度的显示间隔，在类目轴中有效 inside: false, // 坐标轴刻度是否朝内，默认朝外 length: 5, // 坐标轴刻度的长度 lineStyle: &#123; color: ..., width: 1, type: 'solid', // 坐标轴刻度线的类型。 // 'solid'|'dashed'|'dotted' shadowBlur: ..., shadowColor: ..., shadowOffsetX: 0, shadowOffsetY: 0, opacity: ... &#125; &#125;, axisLabel: &#123;...&#125;, // 坐标轴刻度标签的相关设置 splitLine: &#123; // 坐标轴在'grid'区域中的分隔线 show: true, interval: 'auto', lineStyle: &#123;...&#125; &#125;, splitArea: &#123; // 分隔区域的样式设置 interval: 'auto', show: false, // 是否显示分隔区域 areaStyle: &#123; // 分隔区域颜色。分隔区域会按数组中颜色的顺序依次循环设置颜色 color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'], &#125; &#125;, data: [&#123;...&#125;], axisPointer: &#123;...&#125;, zlevel: 0, z: 0,&#125; valueAxis（数值轴）、radiusAxis（极坐标系的径向轴）、angleAxis(极坐标系的角度轴)数值轴、极坐标系的径向轴、极坐标系的角度轴的配置，基本与类目轴一致，可参考’categoryAxis’ line（折线图）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556line: &#123; name: ..., coordinateSystem: 'cartesian2d', // 坐标系 xAxisIndex: 0, yAxisIndex: 0, polarIndex: 0, symbol: 'emptyCircle', // 标记的图形 'circle'|'rect'|'roundRect'|'triangle'|'diamond'|'pin'|'arrow'|'none'，可通过'image://url'设为图片，其中'URL'为图片链接 symbolSize: 4, // 标记的大小 symbolRotate: ..., // 标记的旋转角度 symbolKeepAspect: false, // 是否在缩放时保持该图形的长宽比(仅图片) symbolOffset: [0, 0], // 标记相对于原本位置的偏移 showSymbol: true, // 是否显示'symbol' showAllSymbol: 'auto', hoverAnimation: true, // 是否开启'hover'在拐点标志上的提示动画效果 legendHoverLink: true, // 是否启用图例'hover'时的联动高亮 stack: null, // 数据堆叠，同个类目轴上系列配置相同的'stack'值后，后一个系列的值会在前一个系列的值上相加 cursor: 'pointer', connectNulls: false, // 是否连接空数据 clipOverflow: true, // 是否对超出部分裁剪，默认裁剪 step: false, // 是否是阶梯线图。可设为'true'显示成阶梯线图 label: &#123;...&#125;, // 图形上的文本标签，参考'title' itemStyle: &#123;...&#125;, // 折线拐点标志的样式 lineStyle: &#123;...&#125;, // 线条样式 areaStyle: &#123;...&#125;, // 区域填充样式 emphasis: &#123; // 图形的高亮样式 label: &#123;...&#125;, itemStyle: &#123;...&#125;, &#125;, smooth: false, // 是否平滑曲线显示 smoothMonotone: ..., // 折线平滑后是否在一个维度上保持单调性 sampling: ..., dimensions: [...], encode: &#123;...&#125;, seriesLayoutBy: 'column', datasetIndex: 0, data: [&#123; name: ..., value: ..., symbol: 'circle', symbolSize: 4, symbolRotate: ..., symbolKeepAspect: false, symbolOffset: [0, 0], label: &#123;...&#125;, itemStyle: &#123;...&#125;, emphasis: &#123;...&#125;, tooltip: &#123;...&#125;, &#125;], markPoint: &#123;...&#125;, // 图表标注 markLine: &#123;...&#125;, // 图表标线 markArea: &#123;...&#125;, // 图表标域，常用于标记图表中某个范围的数据 zlevel: 0, z: 2, silent: false, animation: true,&#125; bar（柱形图）12345678910111213141516171819202122232425262728293031323334353637383940bar: &#123; name: ..., legendHoverLink: true, coordinateSystem: 'cartesian2d', xAxisIndex: 0, yAxisIndex: 0, label: &#123;...&#125;, itemStyle: &#123;...&#125;, emphasis: &#123;...&#125;, stack: null, cursor: 'pointer', barWidth: 自适应, // 柱条宽度 barMaxWidth: 自适应, // 柱条最大宽度 barMinHeight: 0, // 柱条最小高度 barGap: 30%, // 柱条间距 想要两柱子重叠，可设为'-100%' barCategoryGap: '20%', // 同一系列的柱间距 large: false, // 是否开启大数据量优化 largeThreshold: 400, // 开启绘制优化的阈值 progressive: 5000, // 渐进式渲染时，每一帧绘制图形数量 progressiveThreshold: 3000, // 启用渐进式渲染的图形数量阈值 progressiveChunkMode: mod, // 分片的方式： // 'sequential'|'mod' dimensions: [...], encode: &#123;...&#125;, // 可定义'data'的某个维度被编码 seriesLayoutBy: 'column', datasetIndex: 0, data: [&#123; name: ..., value: ..., label: &#123;...&#125;, // 单个柱条文本样式设置 itemStyle: &#123;...&#125;, emphasis: &#123;...&#125;, tooltip: &#123;...&#125;, &#125;], markPoint: &#123;...&#125;, markLine: &#123;...&#125;, markArea: &#123;...&#125;, zlevel: 0, z: 2,&#125; pie（饼图）123456789101112131415161718192021222324252627282930313233343536pie: &#123; legendHoverLink: true, hoverAnimation: true, hoverOffset: 10, // 高亮扇区的偏移距离 selectedMode: false, // 选中模式，表示是否支持多个选中 selectedOffset: 10, // 选中扇区的偏移距离 clockwise: true, // 饼图的扇区是否是顺时针排布 startAngle: 90, // 起始角度 minAngle: 0, // 最小的扇区角度 minShowLabelAngle: 0, // 小于该角度的扇区，不显示标签 roseType: false, // 是否展示成南丁格尔图，通过半径区分数据大小 // 'radius' | 'area' avoidLabelOverlap: true, // 是否启用防止标签重叠策略 stillShowZeroSum: true, // 是否在数据和为0的时候不显示扇区 cursor: 'pointer', label: &#123;...&#125;, // 饼图图形上的文本标签，可用于说明图形的一些数据信息 labelLine: &#123; // 标签的视觉引导线样式 show: ..., length: ..., // 视觉引导线第一段的长度 length2: ..., // 视觉引导线第二段的长度 smooth: false, lineStyle: &#123;...&#125;, &#125;, itemStyle: &#123;...&#125;, // 图形样式 emphasis: &#123;...&#125;, zlevel: 0, z: 2, center: ['50%', '50%'], radius: [0, '75%'], // 饼图的半径 seriesLayoutBy: 'column', datasetIndex: 0, data: [&#123;...&#125;], markPoint: &#123;...&#125;, markLine: &#123;...&#125;, markArea: &#123;...&#125;,&#125; polar（极坐标）12345678910111213polar: &#123; zlevel: 0, z: 2, // 极坐标系的中心（圆心）坐标，数组的第一项是横坐标，第二项是纵坐标。 // 支持设置成百分比，第一项是相对于容器宽度，第二项是相对于容器高度 center: ['50%', '50%'], /** 极坐标系的半径。可以为如下类型： number：直接指定外半径值。 string：如，'20%'，表示外半径为可视区尺寸（容器高宽中较小一项）的20%长度 Array.&lt;number|string&gt;：数组的第一项是内半径，第二项是外半径 **/ radius: ...,&#125; radar（雷达坐标系）1234567891011121314151617181920212223242526272829303132333435363738radar: &#123; zlevel: 0, z: 2, center: ['50%', '50%'], radius: 75%, startAngle: 90, name: &#123;...&#125;, // 雷达图每个指示器名称的配置项 可参考title中textStyle nameGap: 15, splitNumber: 5, shape: 'polygon', // 雷达绘制类型 支持'polygon' 和 'circle' scale: false, silent: false, triggerEvent: false, axisLine: &#123; show: true, symbol: 'none', symbolSize: [10, 15], symbolOffset: [0, 0], lineStyle: &#123;...&#125;, &#125;, splitLine: &#123; show: true, lineStyle: &#123;...&#125;, &#125;, splitArea: &#123; show: true, areaStyle: &#123;...&#125;, &#125;, indicator: [ // 雷达图的指示器，用来指定雷达图中的多个变量（维度） // 类似于 直角坐标系中的 data &#123; name: ..., max: ..., min: ..., color: ..., &#125; ],&#125; 结束整理的目的不是记忆，把配置表背下来毫无意义，仅是为了更加好的查询各项图表配置。整理后，对其有了整体认识，这算是一个意外的收获吧。同时将该文收录在个人博客上lostimever.github.io。 参考 Echarts官网 W3Cschool]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用 Hexo 和 GitHub Pages 搭建简单的个人博客]]></title>
    <url>%2F2019%2F05%2F31%2Fbuild-your-blog%2F</url>
    <content type="text"><![CDATA[闲来无事，趁着摸鱼时间，使用Hexo和 GitHub搭建出最简单的个人博客。毕竟磨蹭了很久了，苦于自己的技术水平不够，加上日常懒癌发作，终终终于找到了最简单又免费的方式来搭建个人博客，顺带撸出自己的第一个博文。下面就让我们愉（tong）快（ku）的开始吧！ 准备工作环境先安装好以下应用程序： nodeJs Git 安装过程不再赘述，可自行度娘，安装完毕后，使用npm即可完成Hexo的安装。 1$ npm install -g hexo-cli GitHub注册并登陆好 GitHub 账户 Hexo创建你的项目在控制台执行以下命令 1$ hexo init &lt;folder&gt; 如果你的电脑安装了yarn，执行该脚本后，会自动为你安装依赖（即执行yarn install），否则你还需执行以下命令 12$ cd &lt;folder&gt;$ npm install 至此，你的本地博客已经建立成功，只需要运行 1$ hexo server 并在浏览器上输入地址 localhost:4000 便可预览初始化的博客内容。 GitHub创建自己的仓库进入你的 GitHub 主页，创建一个新的repository。 并输入对应的Repository name，请注意：必须保持格式&lt;username&gt;.github.io，其中&lt;username&gt;替换成你的 GitHub 账户名，例如：lostimever.github.io 点击Create repository即可。 将本地博客上传至GitHub修改本地文件打开之前新建的hexo文件夹，在根目录下有个_config.yml文件，用文本编辑器打开，在最下面找到deploy，修改为：deploy: type: git repository: http://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git branch: master 将&lt;username&gt;替换成你的 GitHub 账户名，并保存即可。 开始部署在命令行中输入： 12$ hexo g$ hexo d 当命令行中显示：INFO Deploy done: git说明部署成功。打开浏览器在地址栏中输入lostimever.github.io(将lostimever改成自己的)，就能看见自己的博客了，别人也可以访问。 可能出现的问题报错：ERROR Deployer not found: git在命令行中输入npm install hexo-deployer-git --save或 yarn add hexo-deployer-git重新执行 12$ hexo g$ hexo d *注意： 笔者安装的hexo的版本为 12hexo: 3.8.0hexo-cli: 2.0.0 不同的版本之间的配置可能有些许不同，注意查看自己的版本。 写博客文章创建新的文章在命令行中输入：hexo new “name”（将name替换成你的文章的标题），然后在source/_posts/里就能看到名为name.md的文件了，现在就可以愉快的写博（tu）客（cao）啦。也可以直接在source/_posts/里直接新建一个名为name.md的文件，注意开头需加入以下内容： --- title: name date: 2019-05-31 21:57:27 tags: --- 文章中如何插入图片Hexo插入图片的方式很多，这里只介绍一种：将图片放在当前文章的目录中。文章的目录可以通过配置_config.yml来生成。 1post_asset_folder: true 将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new &quot;name&quot;，在source/_posts中会生成文章name.md和同名文件夹name。将图片资源放在name中，文章就可以引用图片资源了。 1&#123;% asset_img image.jpg document name %&#125; 发表文章写好文章并保存后，重复 开始部署 中的操作即可。 结束建博一时爽，更新如难产。 参考 hexo官网 Github pages]]></content>
  </entry>
</search>
