<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[你对JavaScript面向对象了解多少？]]></title>
    <url>%2F2019%2F06%2F13%2F%E5%88%9B%E5%BB%BAJavaScript%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[前言前两天看到一个有意思的观点：工具的进步，不代表你能力的进步。前端框架风起云涌，我们用得得心应手，回过头来，脱离框架我们还剩下什么？我觉得这是个值得深思的问题。扯远了，本文主要是想把JavaScript中面向对象的知识做一个整理和回顾，加深印象。 怎怎怎么找对象？new 一个对象没有对象怎么办？new 一个！（单身汪哭晕在厕所） 123456let obj = new Object();obj.name = 'object';obj.value = 11;obj.methods = function() &#123; console.log('this is a object')&#125;; 这便是创建一个对象最简单的方式。但是，每次都要 new 一个，复杂又麻烦，有没有更简单的方式呢？往下看 使用字面量创建what？啥是字面量？字面量：literals，有些书上叫做直接量。看见什么，它就是什么举个栗子： 1234567let obj = &#123; name : 'object'; value : 11; methods : function() &#123; console.log('this is a object') &#125;;&#125;; 简单粗暴？！事实上，如果是简单的创建几个对象，使用字面量创建对象无可厚非，但若有很多相似对象需要创建，这种方式便会产生大量的重复代码，显然这是很不友好的。于是工厂模式应运而生。 工厂模式123456789101112function createFactory(name, value) &#123; let obj = new Object(); obj.name = name; obj.value = value; obj.methods = function() &#123; console.log('this is a object, my name is ' + this.name) &#125;; return obj;&#125;let createFactory1 = factory('saints', 12)let createFactory2 = factory('Google', 50) 工厂模式虽然解决了创建 多个相似对象的问题，但却没有解决对象识别的问题，也就是说，无法区分它们的对象类型。这该怎么办呢？ 构造函数模式先用构造函数模式重写上面的例子： 12345678910function Factory(name, value) &#123; this.name = name; this.value = value; this.methods = function() &#123; console.log('this is a object, my name is ' + this.name) &#125;;&#125;let factory1 = new Factory('saints', 12);let factory2 = new Factory('Google', 50); 这里我们使用一个大写字母F开头的构造函数替代了上例中的createFactory，注意按照约定构造函数的首字母要大写。它和工厂模式有什么区别？ 没有显示的创建对象 直接将属性和方法赋值给了this对象 没有return语句 创建 Factory 实例时，必须使用new操作符 构造函数大法好啊，只不过它也不是万能的，最大的问题是，它的每个方法都要在每个实例上重新创建一次。换句话说，两个实例中调用的构造函数中的method方法不是同一个Function实例：console.log(factory1.method === factory2.method) // false为啥会这样呢？不要忘了，ECMAScript 中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。我们可以把 123this.methods = function() &#123; console.log('this is a object, my name is ' + this.name)&#125;; 看成： 123this.methods = new Function() &#123; console.log('this is a object, my name is ' + this.name)&#125;; 这样看是不是更加清楚了呢？调用同一个方法，却声明了不同的实例，实在浪费资源。大可像下面这样，通过把函数定义转移到构造函数外部来解决这个问题。 123456789101112function Factory(name, value) &#123; this.name = name; this.value = value; this.methods = methods&#125;function methods() &#123; console.log('this is a object, my name is ' + this.name)&#125;let factory1 = new Factory('saints', 12);let factory2 = new Factory('Google', 50); 堪称完美。But！！！ 我为要要在全局作用域中定义一个，只能被某个对象调用的函数呢？ 如果，这个对象有多个方法，那我得在全局作用域中定于多个函数。。。这让我们如何去优（zhuang）雅（bi）的封装一个对象呢？ 好在， 这些问题可以通过使用原型模式来解决。 原型模式我们每创建一个函数，都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象。也就是说，prototype 就是，通过调用构造函数创建的那个对象实例的原型对象。看到这我已经晕了。使用原型对象的好处是：可以让所有对象实例共享它所包含的属性和方法。上代码！ 12345678910111213function Factory() &#123; &#125;Factory.prototype.name = 'saints';Factory.prototype.value = 12;Factory.prototype.methods = function() &#123; console.log('this is a object, my name is ' + this.name)&#125;let factory1 = new Factory();factory1.methods(); // this is a object, my name is saintslet factory2 = new Factory();factory2.methods(); // this is a object, my name is saintsconsole.log(factory1.methods === factory2.methods) // true 这样就完美的解决了属性和方法共享的问题，所有的实例共享同一组属性和方法。 我们要知其然，还要知其所以然，原型模式的原理是什么呢？通过下面的流程图，一目了然： 在默认情况下，所有原型对象都会自动获得一个 constructor (构造函数)属性，这个属性包含一个指向 prototype 属性所在函数的指针，图中，Factory.prototype 指向了原型对象，而 Factory.prototype.constructor 又指回了 Factory 每当代码读取某个对象的某个属性时，都会执行一次搜索，首先会询问实例对象中有没有该属性，如果没有则继续查找原型对象（这就是执行期上下文） 123456let factory1 = new Factory();factory1.name = 'google'let factory2 = new Factory(); console.log(factory1.name); // googleconsole.log(factory2.name); // saints 当为对象实例添加一个属性时， 这个属性屏蔽原型对象中的同名属性，注意是屏蔽，这只会阻止我们去访问这个同名属性，而不会对它做修改。即使将该属性修改为null，也不会恢复我们对原型对象中同名属性的访问，除非使用delete彻底删除该属性。 大家可以看到，每次新增一个属性，都要输入一次Factory.prototype，为了减少不必要的输入，同时更加直观的封装原型对象的功能，我们使用字面量来重写整个原型对象： 12345678function Factory() &#123;&#125;Factory.prototype = &#123; name : 'saints'; value : 12; methods : function() &#123; console.log('this is a object, my name is ' + this.name) &#125;&#125; 有个地方需要注意的是，以对象字面量形式创建的新对象，本质上完全重写了默认的 prototype 对象，因此，此时的Factory.prototype.constructor已不再指向Factory，而是指向了Object。 123let factory1 = new Factory();console.log(factory1.constructor == Factory); //falseconsole.log(factory1.constructor == Object); //true 一般情况下，这种改变不会对我们造成困扰，如果 constructor 的值真的很重要，可以像下面这样特意将它设置回适当的值： 123456789101112function Factory() &#123;&#125;Factory.prototype = &#123; constructor: Factory, name : 'saints'; value : 12; methods : function() &#123; console.log('this is a object, my name is ' + this.name) &#125;&#125;let factory1 = new Factory();console.log(factory1.constructor == Factory); //true 你以为这样就完了么？too young too simple！来谈谈这种方式有哪些问题： 不能给构造函数传递初始化参数，因此，所有实例在默认情况下都将取得相同的属性值。 共享问题 假如原型的属性中包含引用类型，在实例中修改该属性的值，那么，其他实例中对应的属性的值，也会被修改。 因此开发者很少单独使用这种方式来创建对象。 组合使用构造函数模式和原型模式在实际开发过程中，我们使用构造函数模式来定义实例属性，而原型模式用于定义方法和共享的属性： 12345678910111213function Factory(name, value) &#123; this.name = name; this.value = value;&#125;Factory.prototype = &#123; constructor: Factory, methods : function() &#123; console.log('this is a object, my name is ' + this.name) &#125;&#125;let factory1 = new Factory('saints', 22);console.log(factory1.constructor == Factory); //true 每个实例都会有自己的一份实例属性，但同时又共享着方法，最大限度的节省了内存，还支持传递初始参数，优点甚多。在ECMAScript中是使用最广泛、认同度最高的一种创建自定义对象的方法。 动态原型模式动态原型模式，把所有信息都封装在了构造函数中，在构造函数中初始化原型(仅在必要的情况下)，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。 1234567891011function Factory(name, value) &#123; this.name = name; this.value = value; if (typeof this.methods == 'function') &#123; Factory.prototype.methods = function() &#123; console.log('this is a object, my name is ' + this.name) &#125; &#125;&#125;let factory1 = new Factory('saints', 22); Factory是一个构造函数，通过new Factory(…)来生成实例对象。每当一个Factory的对象生成时，Factory内部的代码都会被调用一次。 如果去掉if的话，每new一次(即每当一个实例对象生产时)，都会重新定义一个新的函数，然后挂到Factory.prototype.methods属性上。而实际上，你只需要定义一次就够了，因为所有实例都会共享此属性的。所以如果去掉if的话，会造成没必要的时间和空间浪费；而加上if后，只在new第一个实例时才会定义methods方法，之后就不会了。 假设除了methods方法外，你还定义了很多其他方法，比如sayBye、cry、smile等等。此时你只需要把它们都放到对methods判断的if块里面就可以了。 123456if (typeof this.methods != "function") &#123; Factory.prototype.methods = function() &#123;...&#125;; Factory.prototype.sayBye = function() &#123;...&#125;; Factory.prototype.cry = function() &#123;...&#125;; ...&#125; 万恶的面试题使用 new 操作符，经历了哪些步骤 创建一个新的对象； 将构造函数的作用域赋给新的对象（因此，this就指向了新的对象）； 执行构造函数中的代码（为这个新对象添加属性）； 返回新的对象。 构造函数和普通函数的区别构造函数和其他函数的唯一区别，就在于调用他们的方式不同。任何函数，只要是 通过 new 操作符来调用，那它就可以作为构造函数；任何函数，如果不通过 new 操作符来调用，那它和普通的函数没什么两样。 原型对象的问题 不能给构造函数传递初始化参数，因此，所有实例在默认情况下都将取得相同的属性值。 共享问题 假如原型的属性中包含引用类型，在实例中修改该属性的值，那么，其他实例中对应的属性的值，也会被修改。 结束终终于整理完毕，感觉每次更新都像是难产。不过感觉自己又回到了两年前，初识js，拿着红宝书迷茫的啃。现在依旧迷茫，只是在迷茫的路上，坚定了一点。 本文也收录在个人博客上lostimever.github.io。 参考 《JavaScript高级程序设计》第3版]]></content>
  </entry>
  <entry>
    <title><![CDATA[echarts各项配置]]></title>
    <url>%2F2019%2F06%2F06%2Fecharts%E5%90%84%E9%A1%B9%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[基于版本v4.x 前言吐血整理。Echarts的各种配置真的是眼花缭乱，第一次使用的时候，内心真的是崩溃啊，看到就害怕。最近开始搞项目了，面对一堆图表，更是无所适从，才萌生了整理echarts配置的想法。仅仅整理了常用的，后续如果有需求，会进行补充。 各项配置title（包含主标题和副标题）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152title: &#123; target: 'blank', // 指定窗口打开主标题超链接 // 'self'当前窗口打开 // 'blank'新窗口打开[default] textStyle: &#123; // 主标题文字样式 color: '#333', fontStyle: 'normal', // 字体风格 fontWeight: normal, // 粗细 fontFamily: 'sans-serif', // 字体 fontSize: 18, lineHeight: 56, // 行高 textBorderColor: 'transparent', // 文字本身的描边颜色 textBorderWidth: 0, // 文字本身的描边宽度 textShadowColor: 'transparent', // 文字本身的阴影颜色 textShadowBlur: 0, // 文字本身的阴影长度 textShadowOffsetX: 0, // 文字本身的阴影X偏移 textShadowOffsetY: 0, // 文字本身的阴影Y偏移 &#125;, subtextStyle: &#123; // 副标题样式 align: 'auto', // 文字水平对齐方式 left ¦ center ¦ right verticalAlign: 'auto', // 文字垂直对齐方式 top ¦ middle ¦ bottom &#125;, textAlign: 'auto', // 整体（主副标题）的水平对齐 textVerticalAlign: 'auto', // 整体（主副标题）的垂直对齐 triggerEvent: false, // 是否触发事件 padding: 5, // 标题内边距，单位px，默认各方向内边距为5， // 接受`数组`分别设定上右下左边距，同css itemGap: 10, // 主副标题间距 zlevel: 0, // 用于Canvas分层，内存开销大，谨慎使用 z: 2, // 控制图形的先后顺序，优先级低于zlevel x: 'left', // 水平安放位置，默认为左对齐，可选为： // center ¦ left ¦ right ¦ 像素值 y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // top ¦ bottom ¦ center ¦ 像素值 left: 'auto', // grid 组件容器左侧的距离 // center ¦ left ¦ right ¦ 像素值 ¦ % top: 'auto', // grid 组件容器上侧的距离 // top ¦ middle ¦ bottom ¦ 像素值 ¦ % right: 'auto', // grid 组件容器右侧的距离 // 像素值 ¦ % bottom: 'auto', // grid 组件容器下侧的距离 // 像素值 ¦ % backgroundColor: 'transparent', // 标题背景色 borderColor: '#ccc', // 标题边框颜色 borderWidth: 0, // 标题边框线宽 borderRadius: 0, // 圆角半径 单位px // 接受`数组`分别指定4个圆角半径 shadowBlur: ..., // 图形阴影的模糊大小 shadowColor: ..., // 阴影颜色 shadowOffsetX: 0, // 阴影水平方向上的偏移距离 shadowOffsetY: 0 // 阴影垂直方向上的偏移距离&#125; legend（图例）仅列出图例单独的属性，公共属性如：show、zlevel、x、y、z、left、top、right、bottom、padding、itemGap、backgroundColor、borderColor、borderWidth、borderRadius、shadowBlur、shadowColor、shadowOffsetX、shadowOffsetY以及textStyle中的部分属性，请参考title内容。 123456789101112131415161718192021222324252627282930313233343536373839404142legend: &#123; type: 'plain', // 图例类型： // 'plain'：普通图例；'scroll'：可滚动翻页图例 orient: 'horizontal', // 图例列表的布局朝向：horizontal | vertocal align: 'auto', // 图例标记和文本的对齐：auto | left | right itemWidth: 25, // 图例标记的图形宽度 itemHeight: 14, // 图例标记的图形高度 symbolKeepAspect: true, // 自定义图标时，是否在缩放时保持缩放比 formatter: null, // 格式化图例文本，支持字符串模板和回调函数 selectedMode: true, // 图例选择模式： // 是否可以通过点击图例，改变图表显示状态 inactiveColor: '#ccc', // 图例关闭时的颜色 selected: &#123; // 图例选中状态表 '系列1': true, // 选中'系列1' '系列2': false // 不选中'系列2' &#125;, textStyle: &#123;&#125;, // 图例的公用文本样式，公共样式请参考 `title` tooltip: &#123;...&#125;, // 同tooltip data: [&#123; name: ..., // 图例项的名称，应等于某系列的name值 icon: ..., textStyle: &#123;...&#125;, // 图例的文本样式(single) &#125;], // 以下属性，type为'scroll'时，有效 scrollDataIndex: 0, // 图例当前最左上显示项的`dataIndex` pageButtonItemGap: 5, // 图例控制块中，按钮和页信息之间的间隔 pageButtonGap: null, // 图例控制块和图例之间的间隔 pageButtonPosition: 'end', // 图例控制块的位置： // 'start'：控制块在左或上 // 'end'：控制块在右或下 pageFormatter: '&#123;current&#125;/&#123;total&#125;', // 页信息的显示格式 pageIcons: &#123; horizontal: [...], // orient为'horizontal'时的翻页按钮图标 vertical: [...] // orient为'vertical'时的翻页按钮图标 &#125;, pageIconColor: '#2f4554', // 翻页按钮颜色 pageIconInactiveColor: '#aaa', // 翻页按钮不激活时的颜色 pageIconSize: 15, // 翻页按钮的大小，接受数组、数字 pageTextStyle: &#123;...&#125;, // 图例页信息的文字样式 animation: ..., // 图例翻页是否使用动画 animationDurationUpdate: 800, // 图例翻页时的动画时常&#125; grid（网格）12345678910111213141516171819grid: &#123; show: false, // 是否显示直角坐标系网格 zlevel: 0, z: 2, left: '10%', top: 60, right: '10%', bottom: 60, width: 'auto', height: 'auto', containLabel: false, // grid 区域是否包含坐标轴的刻度标签 backgroundColor: 'transparent', borderColor: '#ccc', borderWidth: 1, shadowBlur: ..., shadowColor: ..., shadowOffsetX: 0, shadowOffsetY: 0,&#125; categoryAxis（类目轴）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475categoryAxis: &#123; show: true, // 是否显示 x 轴 gridIndex: 0, // x轴所在的grid的索引 position: ..., // x轴的位置 'top'|'bootom' offset: 0, // x轴相对于默认位置的偏移 // **在相同的`position`上有多个x轴的时候起作用** name: ..., // 坐标轴名称 nameLocation: 'end', // 坐标轴名称显示位置 // 'start'|'middle'或'center'|'end' nameTextStyle: &#123;...&#125;, // 坐标轴名称的文字样式 nameGap: 15, // 坐标轴名称与轴线之间的距离 nameRotate: null, // 坐标轴名字旋转，角度值 inverse: false, // 是否反向坐标轴 boundaryGap: ..., // 坐标轴两边留白 // 类目轴 'true'|'false' // 非类目轴 数组["20%", "20%"]，数组值可以为百分比或数值 min: null, /** 坐标轴刻度最小值 可以设置成特殊值 'dataMin'，此时取数据在该轴上的最小值作为最小刻度。 当设置成 function 形式时，可以根据计算得出数据的最小值来设定坐标轴的最小值 **/ max: null, // 坐标轴刻度最大值 同理 最小值 scale: false, // 数值轴有效，是否脱离0值比例 splitNumber: 5, // 坐标轴分割段数（预估值）类目轴无效 minInterval: 0, // 自动计算坐标轴最小间隔 设置成1保证坐标轴分割刻度显示成整数 maxInterval: ..., // 自动计算坐标轴最大间隔 interval: ..., // 强制设置坐标轴分割间隔 logBase: 10, // 对数轴的底数，只在对数轴中（type: 'log'）有效 silent: false, // 坐标轴是否是静态无法交互 triggerEvent: false, // 坐标轴的标签是否响应和触发鼠标事件，默认不响应 axisLine: &#123; // 坐标轴轴线相关设置 show: true, // 是否显示坐标轴轴线 onZero: true, // X轴或Y轴的轴线是否在另一个轴的'0'刻度上，只有在另一个轴为数值轴且包含'0'刻度时有效 onZeroAxisIndex: ..., // 当有双轴时，指定在哪个轴的'0'刻度上 symbol: 'none', // 轴线两边的箭头 ['none', 'arrow'] symbolSize: [10, 15], // 轴线两边的箭头的大小，['垂直','水平'] symbolOffset: [0, 0], // 轴线两边的箭头的偏移 &#125;, axisTick: &#123; // 坐标轴刻度相关设置 show: true, alignWithLabel: false, // 类目轴中'boundaryGap'为'true'时有效，保证刻度线和标签对齐 interval: 'auto', // 坐标轴刻度的显示间隔，在类目轴中有效 inside: false, // 坐标轴刻度是否朝内，默认朝外 length: 5, // 坐标轴刻度的长度 lineStyle: &#123; color: ..., width: 1, type: 'solid', // 坐标轴刻度线的类型。 // 'solid'|'dashed'|'dotted' shadowBlur: ..., shadowColor: ..., shadowOffsetX: 0, shadowOffsetY: 0, opacity: ... &#125; &#125;, axisLabel: &#123;...&#125;, // 坐标轴刻度标签的相关设置 splitLine: &#123; // 坐标轴在'grid'区域中的分隔线 show: true, interval: 'auto', lineStyle: &#123;...&#125; &#125;, splitArea: &#123; // 分隔区域的样式设置 interval: 'auto', show: false, // 是否显示分隔区域 areaStyle: &#123; // 分隔区域颜色。分隔区域会按数组中颜色的顺序依次循环设置颜色 color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'], &#125; &#125;, data: [&#123;...&#125;], axisPointer: &#123;...&#125;, zlevel: 0, z: 0,&#125; valueAxis（数值轴）、radiusAxis（极坐标系的径向轴）、angleAxis(极坐标系的角度轴)数值轴、极坐标系的径向轴、极坐标系的角度轴的配置，基本与类目轴一致，可参考’categoryAxis’ line（折线图）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556line: &#123; name: ..., coordinateSystem: 'cartesian2d', // 坐标系 xAxisIndex: 0, yAxisIndex: 0, polarIndex: 0, symbol: 'emptyCircle', // 标记的图形 'circle'|'rect'|'roundRect'|'triangle'|'diamond'|'pin'|'arrow'|'none'，可通过'image://url'设为图片，其中'URL'为图片链接 symbolSize: 4, // 标记的大小 symbolRotate: ..., // 标记的旋转角度 symbolKeepAspect: false, // 是否在缩放时保持该图形的长宽比(仅图片) symbolOffset: [0, 0], // 标记相对于原本位置的偏移 showSymbol: true, // 是否显示'symbol' showAllSymbol: 'auto', hoverAnimation: true, // 是否开启'hover'在拐点标志上的提示动画效果 legendHoverLink: true, // 是否启用图例'hover'时的联动高亮 stack: null, // 数据堆叠，同个类目轴上系列配置相同的'stack'值后，后一个系列的值会在前一个系列的值上相加 cursor: 'pointer', connectNulls: false, // 是否连接空数据 clipOverflow: true, // 是否对超出部分裁剪，默认裁剪 step: false, // 是否是阶梯线图。可设为'true'显示成阶梯线图 label: &#123;...&#125;, // 图形上的文本标签，参考'title' itemStyle: &#123;...&#125;, // 折线拐点标志的样式 lineStyle: &#123;...&#125;, // 线条样式 areaStyle: &#123;...&#125;, // 区域填充样式 emphasis: &#123; // 图形的高亮样式 label: &#123;...&#125;, itemStyle: &#123;...&#125;, &#125;, smooth: false, // 是否平滑曲线显示 smoothMonotone: ..., // 折线平滑后是否在一个维度上保持单调性 sampling: ..., dimensions: [...], encode: &#123;...&#125;, seriesLayoutBy: 'column', datasetIndex: 0, data: [&#123; name: ..., value: ..., symbol: 'circle', symbolSize: 4, symbolRotate: ..., symbolKeepAspect: false, symbolOffset: [0, 0], label: &#123;...&#125;, itemStyle: &#123;...&#125;, emphasis: &#123;...&#125;, tooltip: &#123;...&#125;, &#125;], markPoint: &#123;...&#125;, // 图表标注 markLine: &#123;...&#125;, // 图表标线 markArea: &#123;...&#125;, // 图表标域，常用于标记图表中某个范围的数据 zlevel: 0, z: 2, silent: false, animation: true,&#125; bar（柱形图）12345678910111213141516171819202122232425262728293031323334353637383940bar: &#123; name: ..., legendHoverLink: true, coordinateSystem: 'cartesian2d', xAxisIndex: 0, yAxisIndex: 0, label: &#123;...&#125;, itemStyle: &#123;...&#125;, emphasis: &#123;...&#125;, stack: null, cursor: 'pointer', barWidth: 自适应, // 柱条宽度 barMaxWidth: 自适应, // 柱条最大宽度 barMinHeight: 0, // 柱条最小高度 barGap: 30%, // 柱条间距 想要两柱子重叠，可设为'-100%' barCategoryGap: '20%', // 同一系列的柱间距 large: false, // 是否开启大数据量优化 largeThreshold: 400, // 开启绘制优化的阈值 progressive: 5000, // 渐进式渲染时，每一帧绘制图形数量 progressiveThreshold: 3000, // 启用渐进式渲染的图形数量阈值 progressiveChunkMode: mod, // 分片的方式： // 'sequential'|'mod' dimensions: [...], encode: &#123;...&#125;, // 可定义'data'的某个维度被编码 seriesLayoutBy: 'column', datasetIndex: 0, data: [&#123; name: ..., value: ..., label: &#123;...&#125;, // 单个柱条文本样式设置 itemStyle: &#123;...&#125;, emphasis: &#123;...&#125;, tooltip: &#123;...&#125;, &#125;], markPoint: &#123;...&#125;, markLine: &#123;...&#125;, markArea: &#123;...&#125;, zlevel: 0, z: 2,&#125; pie（饼图）123456789101112131415161718192021222324252627282930313233343536pie: &#123; legendHoverLink: true, hoverAnimation: true, hoverOffset: 10, // 高亮扇区的偏移距离 selectedMode: false, // 选中模式，表示是否支持多个选中 selectedOffset: 10, // 选中扇区的偏移距离 clockwise: true, // 饼图的扇区是否是顺时针排布 startAngle: 90, // 起始角度 minAngle: 0, // 最小的扇区角度 minShowLabelAngle: 0, // 小于该角度的扇区，不显示标签 roseType: false, // 是否展示成南丁格尔图，通过半径区分数据大小 // 'radius' | 'area' avoidLabelOverlap: true, // 是否启用防止标签重叠策略 stillShowZeroSum: true, // 是否在数据和为0的时候不显示扇区 cursor: 'pointer', label: &#123;...&#125;, // 饼图图形上的文本标签，可用于说明图形的一些数据信息 labelLine: &#123; // 标签的视觉引导线样式 show: ..., length: ..., // 视觉引导线第一段的长度 length2: ..., // 视觉引导线第二段的长度 smooth: false, lineStyle: &#123;...&#125;, &#125;, itemStyle: &#123;...&#125;, // 图形样式 emphasis: &#123;...&#125;, zlevel: 0, z: 2, center: ['50%', '50%'], radius: [0, '75%'], // 饼图的半径 seriesLayoutBy: 'column', datasetIndex: 0, data: [&#123;...&#125;], markPoint: &#123;...&#125;, markLine: &#123;...&#125;, markArea: &#123;...&#125;,&#125; polar（极坐标）12345678910111213polar: &#123; zlevel: 0, z: 2, // 极坐标系的中心（圆心）坐标，数组的第一项是横坐标，第二项是纵坐标。 // 支持设置成百分比，第一项是相对于容器宽度，第二项是相对于容器高度 center: ['50%', '50%'], /** 极坐标系的半径。可以为如下类型： number：直接指定外半径值。 string：如，'20%'，表示外半径为可视区尺寸（容器高宽中较小一项）的20%长度 Array.&lt;number|string&gt;：数组的第一项是内半径，第二项是外半径 **/ radius: ...,&#125; radar（雷达坐标系）1234567891011121314151617181920212223242526272829303132333435363738radar: &#123; zlevel: 0, z: 2, center: ['50%', '50%'], radius: 75%, startAngle: 90, name: &#123;...&#125;, // 雷达图每个指示器名称的配置项 可参考title中textStyle nameGap: 15, splitNumber: 5, shape: 'polygon', // 雷达绘制类型 支持'polygon' 和 'circle' scale: false, silent: false, triggerEvent: false, axisLine: &#123; show: true, symbol: 'none', symbolSize: [10, 15], symbolOffset: [0, 0], lineStyle: &#123;...&#125;, &#125;, splitLine: &#123; show: true, lineStyle: &#123;...&#125;, &#125;, splitArea: &#123; show: true, areaStyle: &#123;...&#125;, &#125;, indicator: [ // 雷达图的指示器，用来指定雷达图中的多个变量（维度） // 类似于 直角坐标系中的 data &#123; name: ..., max: ..., min: ..., color: ..., &#125; ],&#125; 结束整理的目的不是记忆，把配置表背下来毫无意义，仅是为了更加好的查询各项图表配置。整理后，对其有了整体认识，这算是一个意外的收获吧。同时将该文收录在个人博客上lostimever.github.io。 参考 Echarts官网 W3Cschool]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用 Hexo 和 GitHub Pages 搭建简单的个人博客]]></title>
    <url>%2F2019%2F05%2F31%2Fbuild-your-blog%2F</url>
    <content type="text"><![CDATA[闲来无事，趁着摸鱼时间，使用Hexo和 GitHub搭建出最简单的个人博客。毕竟磨蹭了很久了，苦于自己的技术水平不够，加上日常懒癌发作，终终终于找到了最简单又免费的方式来搭建个人博客，顺带撸出自己的第一个博文。下面就让我们愉（tong）快（ku）的开始吧！ 准备工作环境先安装好以下应用程序： nodeJs Git 安装过程不再赘述，可自行度娘，安装完毕后，使用npm即可完成Hexo的安装。 1$ npm install -g hexo-cli GitHub注册并登陆好 GitHub 账户 Hexo创建你的项目在控制台执行以下命令 1$ hexo init &lt;folder&gt; 如果你的电脑安装了yarn，执行该脚本后，会自动为你安装依赖（即执行yarn install），否则你还需执行以下命令 12$ cd &lt;folder&gt;$ npm install 至此，你的本地博客已经建立成功，只需要运行 1$ hexo server 并在浏览器上输入地址 localhost:4000 便可预览初始化的博客内容。 GitHub创建自己的仓库进入你的 GitHub 主页，创建一个新的repository。 并输入对应的Repository name，请注意：必须保持格式&lt;username&gt;.github.io，其中&lt;username&gt;替换成你的 GitHub 账户名，例如：lostimever.github.io 点击Create repository即可。 将本地博客上传至GitHub修改本地文件打开之前新建的hexo文件夹，在根目录下有个_config.yml文件，用文本编辑器打开，在最下面找到deploy，修改为：deploy: type: git repository: http://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git branch: master 将&lt;username&gt;替换成你的 GitHub 账户名，并保存即可。 开始部署在命令行中输入： 12$ hexo g$ hexo d 当命令行中显示：INFO Deploy done: git说明部署成功。打开浏览器在地址栏中输入lostimever.github.io(将lostimever改成自己的)，就能看见自己的博客了，别人也可以访问。 可能出现的问题报错：ERROR Deployer not found: git在命令行中输入npm install hexo-deployer-git --save或 yarn add hexo-deployer-git重新执行 12$ hexo g$ hexo d *注意： 笔者安装的hexo的版本为 12hexo: 3.8.0hexo-cli: 2.0.0 不同的版本之间的配置可能有些许不同，注意查看自己的版本。 写博客文章创建新的文章在命令行中输入：hexo new “name”（将name替换成你的文章的标题），然后在source/_posts/里就能看到名为name.md的文件了，现在就可以愉快的写博（tu）客（cao）啦。也可以直接在source/_posts/里直接新建一个名为name.md的文件，注意开头需加入以下内容： --- title: name date: 2019-05-31 21:57:27 tags: --- 文章中如何插入图片Hexo插入图片的方式很多，这里只介绍一种：将图片放在当前文章的目录中。文章的目录可以通过配置_config.yml来生成。 1post_asset_folder: true 将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new &quot;name&quot;，在source/_posts中会生成文章name.md和同名文件夹name。将图片资源放在name中，文章就可以引用图片资源了。 1&#123;% asset_img image.jpg document name %&#125; 发表文章写好文章并保存后，重复 开始部署 中的操作即可。 结束建博一时爽，更新如难产。 参考 hexo官网 Github pages]]></content>
  </entry>
</search>
