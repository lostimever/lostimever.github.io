<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>暮色</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-09T01:49:49.354Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Linfeng Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript 中什么样的继承才是好的继承？</title>
    <link href="http://yoursite.com/2019/07/09/javascriptinherit/"/>
    <id>http://yoursite.com/2019/07/09/javascriptinherit/</id>
    <published>2019-07-09T01:48:30.000Z</published>
    <updated>2019-07-09T01:49:49.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>理解对象和继承是我们学习设计模式，甚至是阅读各种框架源码的第一步。上一篇文章，笔者已经把JavaScript对象进行了梳理，今天我们来一起学习继承。</p><a id="more"></a><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法，也就是将一个原型对象指向另一个引用类型的实例。<br>Example:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>() &#123;</span><br><span class="line">  this.property = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getParentValue = () =&gt; this.property</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123;</span><br><span class="line">  this.childProperty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = new Parent()</span><br><span class="line">Child.prototype.getChildValue = () =&gt; this.childProperty</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> instance = new Child()</span><br><span class="line">console.log(instance.getParentValue()) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><code>Child</code> 通过创建 <code>Parent</code> 实例，并将实例赋值给 <code>Child.prototype</code> 的方式，继承了 <code>Parent</code> 。本质是利用实例重写了原型对象。这样，<code>Child.prototype</code> 拥有了 <code>Parent</code> 的全部属性和方法，同时其内部指针也指向了 <code>Parent.prototype</code> 。<br>通过实现原型链，本质上拓展了原型搜索机制。</p><p>添加方法（谨慎）：<br>字类型有时需要重写超类型中的某个方法，或新增超类型中不存在的方法，一定要将给原型添加方法的代码放在被替换原型的语句后面。<br>Example：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>() &#123; </span><br><span class="line">    this.property = <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getParentValue = () =&gt; this.property</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123; </span><br><span class="line">    this.childProperty = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//继承了 SuperType </span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line"></span><br><span class="line">//添加新方法 </span><br><span class="line">Child.prototype.getChildValue = () =&gt; this.childProperty</span><br><span class="line"></span><br><span class="line">//重写超类型中的方法 </span><br><span class="line">Child.prototype.getParentValue = () =&gt; <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> instance = new ChildType(); </span><br><span class="line">console.log(instance.getParentValue());   //<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>原型链继承存在的问题：</p><ol><li>创建子类型实例时，不能向父类的构造函数中传递参数</li><li>父子构造函数的原型对象之间存在共享问题<br>example：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>()&#123; </span><br><span class="line">    this.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123;&#125;</span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> instanceChild = new Child();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">console.log(instanceChild.colors);   //<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>,<span class="string">"black"</span></span><br><span class="line">//当我们改变colors的时候, 父构造函数的原型对象的也会变化</span><br><span class="line"><span class="built_in">let</span> instanceParent = new Parent();</span><br><span class="line">console.log(instanceParent.colors);   //<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>,<span class="string">"black"</span></span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>基本思想：在子类构造函数的内部，调用父类的构造函数<br>Example:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Parent(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>() &#123;</span><br><span class="line">    Parent.call(this, <span class="string">"jerry"</span>);  // 继承了 Parent</span><br><span class="line">    this.age = 22;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> instanceChild = new Child();</span><br><span class="line">instanceChild.colors.push(<span class="string">"black"</span>);</span><br><span class="line">console.log(instanceChild.name);    // jerry</span><br><span class="line">console.log(instanceChild.colors);   //<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>,<span class="string">"black"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> instanceParent = new Parent();</span><br><span class="line">console.log(instanceParent.colors);   //<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span></span><br></pre></td></tr></table></figure><p>构造函数问题：</p><ol><li>方法都在构造函数中定义，因此函数很难复用</li><li>在父类原型对象中定义的方法，子类无法继承</li></ol><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>简单的说：原型链+构造函数<br>基本思想：原型链实现对原型属性和方法的继承，构造函数实现对实例属性的继承<br>Example：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Parent(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = () =&gt; &#123; console.log(this.name) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Child(name, age) &#123;</span><br><span class="line">    Parent.call(this, name);    // 继承属性</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承方法</span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line">Child.prototype.sayAge = () =&gt; &#123; console.log(this.age) &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> instanceChild = new Child(<span class="string">"jerry"</span>, 23);</span><br><span class="line">instanceChild.colors.push(<span class="string">"black"</span>); </span><br><span class="line">console.log(instanceChild.colors);  //<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>,<span class="string">"black"</span></span><br><span class="line">instanceChild.sayName();        // jerry</span><br><span class="line">instanceChild.sayAge();         // 23</span><br></pre></td></tr></table></figure><p>存在问题：</p><ol><li>若再添加一个子类型，给其原型单独添加一个方法，那么其他子类型也同时拥有了这个方法，因为它们都指向同一个父类型的原型</li><li>无论在什么情况下都会调用两次父类的构造函数，我们不得不在调用子类构造函数时，重写这些属性。</li></ol><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>基本思想： 本质是对继承对象执行了一次浅拷贝。<br>example：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> object(o) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">F</span></span>() &#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="built_in">return</span> new F();</span><br><span class="line">&#125;</span><br><span class="line">// ES5内置了object.create()方法可以以上方法的功能。</span><br><span class="line"><span class="built_in">let</span> parent = &#123;</span><br><span class="line">    name: <span class="string">"jerry"</span>,</span><br><span class="line">    friends: [<span class="string">"marry"</span>, <span class="string">"sandy"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> Child1 = object(parent);</span><br><span class="line">Child1.name = <span class="string">"barbie"</span>;</span><br><span class="line">Child1.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> Child2 = object(parent);</span><br><span class="line">Child2.name = <span class="string">"Cos"</span>;</span><br><span class="line">Child2.friends.push(<span class="string">"Linda"</span>);</span><br><span class="line"></span><br><span class="line">console.log(parent.friends);    //<span class="string">"marry"</span>, <span class="string">"sandy"</span>,<span class="string">"Rob"</span>,<span class="string">"Linda"</span></span><br></pre></td></tr></table></figure><p>存在问题：</p><ol><li>与原型链继承一样，父子对象之间存在共享问题</li><li>无法实现复用 </li></ol><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>基本思路：在原型式继承外面套了一层函数，在该函数内部增强对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> object(o) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">F</span></span>() &#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="built_in">return</span> new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 壳子</span><br><span class="line"><span class="keyword">function</span> createAnother(original) &#123;</span><br><span class="line">    <span class="built_in">let</span> <span class="built_in">clone</span> = object(original);</span><br><span class="line">    clone.sayHi = () =&gt; &#123; console.log(<span class="string">"Hi"</span>) &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">clone</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在问题：</p><ol><li>复用率贼低</li></ol><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>基本思想： 利用构造函数来继承属性，利用原型链的混成形式来继承方法。<br>example:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> object(o) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">F</span></span>() &#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="built_in">return</span> new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> inheritPrototype(child, parent) &#123;</span><br><span class="line">    <span class="built_in">let</span> prototype = object(parent.prototype)</span><br><span class="line">    prototype.constructor = child;</span><br><span class="line">    child.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Parent(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = () =&gt; &#123; console.log(this.name) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Child(name, age) &#123;</span><br><span class="line">    Parent.call(this, name);    // 继承属性</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Child, Parent)</span><br><span class="line"></span><br><span class="line">Child.prototype.sayAge = () =&gt; this.age</span><br></pre></td></tr></table></figure><p>目前来说，这是最好的继承方式。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>懒癌发作，明明早就写好了，一直把他丢弃在电脑硬盘里。几周之后，我挣扎着打开MWeb，稍做修葺，赶个结束语。算是画上一个句号吧。最后，不得不说，高级3，真是一本不可多得的好书，把对象、继承讲得如此清晰明了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《JavaScript高级程序设计》第3版</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;理解对象和继承是我们学习设计模式，甚至是阅读各种框架源码的第一步。上一篇文章，笔者已经把JavaScript对象进行了梳理，今天我们来一起学习继承。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>你对JavaScript面向对象了解多少？</title>
    <link href="http://yoursite.com/2019/06/13/%E5%88%9B%E5%BB%BAJavaScript%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/06/13/创建JavaScript对象/</id>
    <published>2019-06-13T07:57:44.000Z</published>
    <updated>2019-06-13T08:40:18.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前两天看到一个有意思的观点：工具的进步，不代表你能力的进步。前端框架风起云涌，我们用得得心应手，回过头来，脱离框架我们还剩下什么？我觉得这是个值得深思的问题。<br>扯远了，本文主要是想把JavaScript中面向对象的知识做一个整理和回顾，加深印象。</p><a id="more"></a><h2 id="怎怎怎么找对象？"><a href="#怎怎怎么找对象？" class="headerlink" title="怎怎怎么找对象？"></a>怎怎怎么找对象？</h2><h3 id="new-一个对象"><a href="#new-一个对象" class="headerlink" title="new 一个对象"></a>new 一个对象</h3><p>没有对象怎么办？<br>new 一个！（单身汪哭晕在厕所）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = new Object();</span><br><span class="line">obj.name = <span class="string">'object'</span>;</span><br><span class="line">obj.value = 11;</span><br><span class="line">obj.methods = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'this is a object'</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这便是创建一个对象最简单的方式。但是，每次都要 new 一个，复杂又麻烦，有没有更简单的方式呢？<br>往下看</p><h3 id="使用字面量创建"><a href="#使用字面量创建" class="headerlink" title="使用字面量创建"></a>使用字面量创建</h3><p>what？啥是字面量？<br>字面量：literals，有些书上叫做直接量。看见什么，它就是什么<br>举个栗子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'object'</span>;</span><br><span class="line">    value : 11;</span><br><span class="line">    methods : <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">'this is a object'</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单粗暴？！事实上，如果是简单的创建几个对象，使用字面量创建对象无可厚非，但若有很多相似对象需要创建，这种方式便会产生大量的重复代码，显然这是很不友好的。<br>于是工厂模式应运而生。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createFactory(name, value) &#123;</span><br><span class="line">    <span class="built_in">let</span> obj = new Object();</span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.value = value;</span><br><span class="line">    obj.methods = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">'this is a object, my name is '</span> + this.name)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> createFactory1 = factory(<span class="string">'saints'</span>, 12)</span><br><span class="line"><span class="built_in">let</span> createFactory2 = factory(<span class="string">'Google'</span>, 50)</span><br></pre></td></tr></table></figure><p>工厂模式虽然解决了创建 多个相似对象的问题，但却没有解决对象识别的问题，也就是说，无法区分它们的对象类型。<br>这该怎么办呢？</p><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>先用构造函数模式重写上面的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Factory(name, value) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.value = value;</span><br><span class="line">    this.methods = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">'this is a object, my name is '</span> + this.name)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> factory1 = new Factory(<span class="string">'saints'</span>, 12);</span><br><span class="line"><span class="built_in">let</span> factory2 = new Factory(<span class="string">'Google'</span>, 50);</span><br></pre></td></tr></table></figure><p>这里我们使用一个大写字母F开头的构造函数替代了上例中的createFactory，注意按照约定构造函数的首字母要大写。<br>它和工厂模式有什么区别？</p><ol><li>没有显示的创建对象</li><li>直接将属性和方法赋值给了this对象</li><li>没有return语句</li><li>创建 Factory 实例时，必须使用new操作符</li></ol><p>构造函数大法好啊，只不过它也不是万能的，最大的问题是，它的每个方法都要在每个实例上重新创建一次。<br>换句话说，两个实例中调用的构造函数中的method方法不是同一个Function实例：<br><code>console.log(factory1.method === factory2.method) // false</code><br>为啥会这样呢？<br>不要忘了，ECMAScript 中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。<br>我们可以把</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.methods = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'this is a object, my name is '</span> + this.name)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.methods = new <span class="function"><span class="title">Function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'this is a object, my name is '</span> + this.name)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样看是不是更加清楚了呢？<br>调用同一个方法，却声明了不同的实例，实在浪费资源。大可像下面这样，通过把函数定义转移到构造函数外部来解决这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Factory(name, value) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.value = value;</span><br><span class="line">    this.methods = methods</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">methods</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'this is a object, my name is '</span> + this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> factory1 = new Factory(<span class="string">'saints'</span>, 12);</span><br><span class="line"><span class="built_in">let</span> factory2 = new Factory(<span class="string">'Google'</span>, 50);</span><br></pre></td></tr></table></figure><p>堪称完美。<br>But！！！</p><ol><li>我为要要在全局作用域中定义一个，只能被某个对象调用的函数呢？</li><li>如果，这个对象有多个方法，那我得在全局作用域中定于多个函数。。。这让我们如何去优（zhuang）雅（bi）的封装一个对象呢？</li></ol><p>好在， 这些问题可以通过使用原型模式来解决。</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>我们每创建一个函数，都有一个<code>prototype</code>（原型）属性，这个属性是一个指针，指向一个对象。也就是说，<code>prototype</code> 就是，通过调用构造函数创建的那个对象实例的原型对象。看到这我已经晕了。<br>使用原型对象的好处是：可以让所有对象实例共享它所包含的属性和方法。<br>上代码！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Factory</span></span>() &#123; &#125;</span><br><span class="line">Factory.prototype.name = <span class="string">'saints'</span>;</span><br><span class="line">Factory.prototype.value = 12;</span><br><span class="line">Factory.prototype.methods = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'this is a object, my name is '</span> + this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> factory1 = new Factory();</span><br><span class="line">factory1.methods(); // this is a object, my name is saints</span><br><span class="line"><span class="built_in">let</span> factory2 = new Factory();</span><br><span class="line">factory2.methods(); // this is a object, my name is saints</span><br><span class="line"></span><br><span class="line">console.log(factory1.methods === factory2.methods) // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这样就完美的解决了属性和方法共享的问题，所有的实例共享同一组属性和方法。</p><p>我们要知其然，还要知其所以然，原型模式的原理是什么呢？<br>通过下面的流程图，一目了然：</p><img src="/2019/06/13/创建JavaScript对象/prototype.jpg" title="build-your-blog"><p>在默认情况下，所有原型对象都会自动获得一个 constructor (构造函数)属性，这个属性包含一个指向 prototype 属性所在函数的指针，图中，Factory.prototype 指向了原型对象，而 Factory.prototype.constructor 又指回了 Factory</p><p>每当代码读取某个对象的某个属性时，都会执行一次搜索，首先会询问实例对象中有没有该属性，如果没有则继续查找原型对象（这就是执行期上下文）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> factory1 = new Factory();</span><br><span class="line">factory1.name = <span class="string">'google'</span></span><br><span class="line"><span class="built_in">let</span> factory2 = new Factory(); </span><br><span class="line"></span><br><span class="line">console.log(factory1.name); // google</span><br><span class="line">console.log(factory2.name); // saints</span><br></pre></td></tr></table></figure><p>当为对象实例添加一个属性时， 这个属性屏蔽原型对象中的同名属性，注意是屏蔽，这只会阻止我们去访问这个同名属性，而不会对它做修改。即使将该属性修改为null，也不会恢复我们对原型对象中同名属性的访问，除非使用delete彻底删除该属性。</p><p>大家可以看到，每次新增一个属性，都要输入一次Factory.prototype，为了减少不必要的输入，同时更加直观的封装原型对象的功能，我们使用字面量来重写整个原型对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Factory</span></span>() &#123;&#125;</span><br><span class="line">Factory.prototype = &#123;</span><br><span class="line">    name : <span class="string">'saints'</span>;</span><br><span class="line">    value : 12;</span><br><span class="line">    methods : <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">'this is a object, my name is '</span> + this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个地方需要注意的是，以对象字面量形式创建的新对象，本质上完全重写了默认的 prototype 对象，因此，此时的Factory.prototype.constructor已不再指向Factory，而是指向了Object。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> factory1 = new Factory();</span><br><span class="line">console.log(factory1.constructor == Factory);  //<span class="literal">false</span></span><br><span class="line">console.log(factory1.constructor == Object);   //<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>一般情况下，这种改变不会对我们造成困扰，如果 constructor 的值真的很重要，可以像下面这样特意将它设置回适当的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Factory</span></span>() &#123;&#125;</span><br><span class="line">Factory.prototype = &#123;</span><br><span class="line">    constructor: Factory,</span><br><span class="line">    name : <span class="string">'saints'</span>;</span><br><span class="line">    value : 12;</span><br><span class="line">    methods : <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">'this is a object, my name is '</span> + this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> factory1 = new Factory();</span><br><span class="line">console.log(factory1.constructor == Factory);  //<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>你以为这样就完了么？too young too simple！<br>来谈谈这种方式有哪些问题：</p><ol><li>不能给构造函数传递初始化参数，因此，所有实例在默认情况下都将取得相同的属性值。</li><li>共享问题<br> 假如原型的属性中包含引用类型，在实例中修改该属性的值，那么，其他实例中对应的属性的值，也会被修改。</li></ol><p>因此开发者很少单独使用这种方式来创建对象。</p><h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p>在实际开发过程中，我们使用构造函数模式来定义实例属性，而原型模式用于定义方法和共享的属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Factory(name, value) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.value = value;</span><br><span class="line">&#125;</span><br><span class="line">Factory.prototype = &#123;</span><br><span class="line">    constructor: Factory,</span><br><span class="line">    methods : <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">'this is a object, my name is '</span> + this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> factory1 = new Factory(<span class="string">'saints'</span>, 22);</span><br><span class="line">console.log(factory1.constructor == Factory);  //<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>每个实例都会有自己的一份实例属性，但同时又共享着方法，最大限度的节省了内存，还支持传递初始参数，优点甚多。在ECMAScript中是使用最广泛、认同度最高的一种创建自定义对象的方法。</p><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>动态原型模式，把所有信息都封装在了构造函数中，在构造函数中初始化原型(仅在必要的情况下)，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Factory(name, value) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.value = value;</span><br><span class="line">    <span class="keyword">if</span> (typeof this.methods == <span class="string">'function'</span>) &#123;</span><br><span class="line">        Factory.prototype.methods = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            console.log(<span class="string">'this is a object, my name is '</span> + this.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> factory1 = new Factory(<span class="string">'saints'</span>, 22);</span><br></pre></td></tr></table></figure><p>Factory是一个构造函数，通过new Factory(…)来生成实例对象。每当一个Factory的对象生成时，Factory内部的代码都会被调用一次。</p><p>如果去掉if的话，每new一次(即每当一个实例对象生产时)，都会重新定义一个新的函数，然后挂到Factory.prototype.methods属性上。而实际上，你只需要定义一次就够了，因为所有实例都会共享此属性的。所以如果去掉if的话，会造成没必要的时间和空间浪费；而加上if后，只在new第一个实例时才会定义methods方法，之后就不会了。</p><p>假设除了methods方法外，你还定义了很多其他方法，比如sayBye、cry、smile等等。此时你只需要把它们都放到对methods判断的if块里面就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (typeof this.methods != <span class="string">"function"</span>) &#123;</span><br><span class="line">    Factory.prototype.methods = <span class="function"><span class="title">function</span></span>() &#123;...&#125;;</span><br><span class="line">    Factory.prototype.sayBye = <span class="function"><span class="title">function</span></span>() &#123;...&#125;;</span><br><span class="line">    Factory.prototype.cry = <span class="function"><span class="title">function</span></span>() &#123;...&#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="万恶的面试题"><a href="#万恶的面试题" class="headerlink" title="万恶的面试题"></a>万恶的面试题</h2><h3 id="使用-new-操作符，经历了哪些步骤"><a href="#使用-new-操作符，经历了哪些步骤" class="headerlink" title="使用 new 操作符，经历了哪些步骤"></a>使用 new 操作符，经历了哪些步骤</h3><ol><li>创建一个新的对象；</li><li>将构造函数的作用域赋给新的对象（因此，this就指向了新的对象）；</li><li>执行构造函数中的代码（为这个新对象添加属性）；</li><li>返回新的对象。</li></ol><h3 id="构造函数和普通函数的区别"><a href="#构造函数和普通函数的区别" class="headerlink" title="构造函数和普通函数的区别"></a>构造函数和普通函数的区别</h3><p>构造函数和其他函数的唯一区别，就在于调用他们的方式不同。<br>任何函数，只要是 通过 new 操作符来调用，那它就可以作为构造函数；<br>任何函数，如果不通过 new 操作符来调用，那它和普通的函数没什么两样。</p><h3 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h3><ol><li>不能给构造函数传递初始化参数，因此，所有实例在默认情况下都将取得相同的属性值。</li><li>共享问题<br> 假如原型的属性中包含引用类型，在实例中修改该属性的值，那么，其他实例中对应的属性的值，也会被修改。</li></ol><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>终终于整理完毕，感觉每次更新都像是难产。不过感觉自己又回到了两年前，初识js，拿着红宝书迷茫的啃。现在依旧迷茫，只是在迷茫的路上，坚定了一点。</p><p>本文也收录在个人博客上<a href="lostimever.github.io">lostimever.github.io</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《JavaScript高级程序设计》第3版</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前两天看到一个有意思的观点：工具的进步，不代表你能力的进步。前端框架风起云涌，我们用得得心应手，回过头来，脱离框架我们还剩下什么？我觉得这是个值得深思的问题。&lt;br&gt;扯远了，本文主要是想把JavaScript中面向对象的知识做一个整理和回顾，加深印象。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>echarts各项配置</title>
    <link href="http://yoursite.com/2019/06/06/echarts%E5%90%84%E9%A1%B9%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/06/06/echarts各项配置/</id>
    <published>2019-06-06T03:35:15.000Z</published>
    <updated>2019-06-06T04:01:54.173Z</updated>
    
    <content type="html"><![CDATA[<p>基于版本v4.x</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>吐血整理。<br>Echarts的各种配置真的是眼花缭乱，第一次使用的时候，内心真的是崩溃啊，看到就害怕。最近开始搞项目了，面对一堆图表，更是无所适从，才萌生了整理echarts配置的想法。仅仅整理了常用的，后续如果有需求，会进行补充。</p><a id="more"></a><h2 id="各项配置"><a href="#各项配置" class="headerlink" title="各项配置"></a>各项配置</h2><h3 id="title（包含主标题和副标题）"><a href="#title（包含主标题和副标题）" class="headerlink" title="title（包含主标题和副标题）"></a>title（包含主标题和副标题）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;</span><br><span class="line">    target: <span class="string">'blank'</span>,                // 指定窗口打开主标题超链接</span><br><span class="line">                                    // <span class="string">'self'</span>当前窗口打开 </span><br><span class="line">                                    // <span class="string">'blank'</span>新窗口打开[default]</span><br><span class="line">    textStyle: &#123;                    // 主标题文字样式</span><br><span class="line">        color: <span class="string">'#333'</span>,</span><br><span class="line">        fontStyle: <span class="string">'normal'</span>,        // 字体风格 </span><br><span class="line">        fontWeight: normal,         // 粗细</span><br><span class="line">        fontFamily: <span class="string">'sans-serif'</span>,   // 字体</span><br><span class="line">        fontSize: 18,</span><br><span class="line">        lineHeight: 56,             // 行高</span><br><span class="line">        textBorderColor: <span class="string">'transparent'</span>,     // 文字本身的描边颜色</span><br><span class="line">        textBorderWidth: 0,                 // 文字本身的描边宽度</span><br><span class="line">        textShadowColor: <span class="string">'transparent'</span>,     // 文字本身的阴影颜色</span><br><span class="line">        textShadowBlur: 0,                  // 文字本身的阴影长度</span><br><span class="line">        textShadowOffsetX: 0,               // 文字本身的阴影X偏移</span><br><span class="line">        textShadowOffsetY: 0,               // 文字本身的阴影Y偏移</span><br><span class="line">    &#125;,</span><br><span class="line">    subtextStyle: &#123;             // 副标题样式</span><br><span class="line">        align: <span class="string">'auto'</span>,          // 文字水平对齐方式 left ¦ center ¦ right</span><br><span class="line">        verticalAlign: <span class="string">'auto'</span>,  // 文字垂直对齐方式 top ¦ middle ¦ bottom</span><br><span class="line">    &#125;,</span><br><span class="line">    textAlign: <span class="string">'auto'</span>,          // 整体（主副标题）的水平对齐</span><br><span class="line">    textVerticalAlign: <span class="string">'auto'</span>,  // 整体（主副标题）的垂直对齐</span><br><span class="line">    triggerEvent: <span class="literal">false</span>,        // 是否触发事件</span><br><span class="line">    padding: 5,                 // 标题内边距，单位px，默认各方向内边距为5，</span><br><span class="line">                                // 接受`数组`分别设定上右下左边距，同css</span><br><span class="line">    itemGap: 10,                // 主副标题间距</span><br><span class="line">    zlevel: 0,                  // 用于Canvas分层，内存开销大，谨慎使用</span><br><span class="line">    z: 2,                       // 控制图形的先后顺序，优先级低于zlevel</span><br><span class="line">    x: <span class="string">'left'</span>,                  // 水平安放位置，默认为左对齐，可选为：</span><br><span class="line">                                // center ¦ left ¦ right ¦ 像素值</span><br><span class="line">    y: <span class="string">'top'</span>,                   // 垂直安放位置，默认为全图顶端，可选为：</span><br><span class="line">                                // top ¦ bottom ¦ center ¦ 像素值</span><br><span class="line">    left: <span class="string">'auto'</span>,               // grid 组件容器左侧的距离</span><br><span class="line">                                // center ¦ left ¦ right ¦ 像素值 ¦ %</span><br><span class="line">    top: <span class="string">'auto'</span>,                // grid 组件容器上侧的距离 </span><br><span class="line">                                // top ¦ middle ¦ bottom ¦ 像素值 ¦ %</span><br><span class="line">    right: <span class="string">'auto'</span>,              // grid 组件容器右侧的距离</span><br><span class="line">                                // 像素值 ¦ %</span><br><span class="line">    bottom: <span class="string">'auto'</span>,             // grid 组件容器下侧的距离</span><br><span class="line">                                // 像素值 ¦ %</span><br><span class="line">    backgroundColor: <span class="string">'transparent'</span>,     // 标题背景色</span><br><span class="line">    borderColor: <span class="string">'#ccc'</span>,                // 标题边框颜色</span><br><span class="line">    borderWidth: 0,                     // 标题边框线宽</span><br><span class="line">    borderRadius: 0,                    // 圆角半径 单位px </span><br><span class="line">                                        // 接受`数组`分别指定4个圆角半径</span><br><span class="line">    shadowBlur: ...,                    // 图形阴影的模糊大小</span><br><span class="line">    shadowColor: ...,                   // 阴影颜色</span><br><span class="line">    shadowOffsetX: 0,                   // 阴影水平方向上的偏移距离</span><br><span class="line">    shadowOffsetY: 0                    // 阴影垂直方向上的偏移距离</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="legend（图例）"><a href="#legend（图例）" class="headerlink" title="legend（图例）"></a>legend（图例）</h3><p>仅列出图例单独的属性，公共属性如：<code>show</code>、<code>zlevel</code>、<code>x</code>、<code>y</code>、<code>z</code>、<code>left</code>、<code>top</code>、<code>right</code>、<code>bottom</code>、<code>padding</code>、<code>itemGap</code>、<code>backgroundColor</code>、<code>borderColor</code>、<code>borderWidth</code>、<code>borderRadius</code>、<code>shadowBlur</code>、<code>shadowColor</code>、<code>shadowOffsetX</code>、<code>shadowOffsetY</code>以及<code>textStyle</code>中的部分属性，请参考title内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">legend: &#123;</span><br><span class="line">    <span class="built_in">type</span>: <span class="string">'plain'</span>,          // 图例类型：</span><br><span class="line">                            // <span class="string">'plain'</span>：普通图例；<span class="string">'scroll'</span>：可滚动翻页图例</span><br><span class="line">    orient: <span class="string">'horizontal'</span>,   // 图例列表的布局朝向：horizontal | vertocal</span><br><span class="line">    align: <span class="string">'auto'</span>,          // 图例标记和文本的对齐：auto | left | right</span><br><span class="line">    itemWidth: 25,          // 图例标记的图形宽度</span><br><span class="line">    itemHeight: 14,         // 图例标记的图形高度</span><br><span class="line">    symbolKeepAspect: <span class="literal">true</span>, // 自定义图标时，是否在缩放时保持缩放比</span><br><span class="line">    formatter: null,        // 格式化图例文本，支持字符串模板和回调函数</span><br><span class="line">    selectedMode: <span class="literal">true</span>,     // 图例选择模式：</span><br><span class="line">                            // 是否可以通过点击图例，改变图表显示状态</span><br><span class="line">    inactiveColor: <span class="string">'#ccc'</span>,  // 图例关闭时的颜色</span><br><span class="line">    selected: &#123;             // 图例选中状态表</span><br><span class="line">        <span class="string">'系列1'</span>: <span class="literal">true</span>,       // 选中<span class="string">'系列1'</span></span><br><span class="line">        <span class="string">'系列2'</span>: <span class="literal">false</span>       // 不选中<span class="string">'系列2'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    textStyle: &#123;&#125;,          // 图例的公用文本样式，公共样式请参考 `title`</span><br><span class="line">    tooltip: &#123;...&#125;,         // 同tooltip</span><br><span class="line">    data: [&#123;</span><br><span class="line">        name: ...,          // 图例项的名称，应等于某系列的name值          </span><br><span class="line">        icon: ...,          </span><br><span class="line">        textStyle: &#123;...&#125;,   // 图例的文本样式(single)</span><br><span class="line">    &#125;],</span><br><span class="line">    // 以下属性，<span class="built_in">type</span>为<span class="string">'scroll'</span>时，有效</span><br><span class="line">    scrollDataIndex: 0,     // 图例当前最左上显示项的`dataIndex`</span><br><span class="line">    pageButtonItemGap: 5,   // 图例控制块中，按钮和页信息之间的间隔</span><br><span class="line">    pageButtonGap: null,    // 图例控制块和图例之间的间隔</span><br><span class="line">    pageButtonPosition: <span class="string">'end'</span>,          // 图例控制块的位置：</span><br><span class="line">                                        // <span class="string">'start'</span>：控制块在左或上</span><br><span class="line">                                        // <span class="string">'end'</span>：控制块在右或下</span><br><span class="line">    pageFormatter: <span class="string">'&#123;current&#125;/&#123;total&#125;'</span>, // 页信息的显示格式</span><br><span class="line">    pageIcons: &#123;</span><br><span class="line">        horizontal: [...],  // orient为<span class="string">'horizontal'</span>时的翻页按钮图标</span><br><span class="line">        vertical: [...]     // orient为<span class="string">'vertical'</span>时的翻页按钮图标</span><br><span class="line">    &#125;,</span><br><span class="line">    pageIconColor: <span class="string">'#2f4554'</span>,       // 翻页按钮颜色</span><br><span class="line">    pageIconInactiveColor: <span class="string">'#aaa'</span>,  // 翻页按钮不激活时的颜色</span><br><span class="line">    pageIconSize: 15,               // 翻页按钮的大小，接受数组、数字</span><br><span class="line">    pageTextStyle: &#123;...&#125;,           // 图例页信息的文字样式</span><br><span class="line">    animation: ...,                 // 图例翻页是否使用动画</span><br><span class="line">    animationDurationUpdate: 800,   // 图例翻页时的动画时常</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="grid（网格）"><a href="#grid（网格）" class="headerlink" title="grid（网格）"></a>grid（网格）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">grid: &#123;</span><br><span class="line">    show: <span class="literal">false</span>,            // 是否显示直角坐标系网格</span><br><span class="line">    zlevel: 0,</span><br><span class="line">    z: 2,</span><br><span class="line">    left: <span class="string">'10%'</span>,</span><br><span class="line">    top: 60,</span><br><span class="line">    right: <span class="string">'10%'</span>,</span><br><span class="line">    bottom: 60,</span><br><span class="line">    width: <span class="string">'auto'</span>,</span><br><span class="line">    height: <span class="string">'auto'</span>,</span><br><span class="line">    containLabel: <span class="literal">false</span>,    // grid 区域是否包含坐标轴的刻度标签</span><br><span class="line">    backgroundColor: <span class="string">'transparent'</span>,</span><br><span class="line">    borderColor: <span class="string">'#ccc'</span>,</span><br><span class="line">    borderWidth: 1,</span><br><span class="line">    shadowBlur: ...,</span><br><span class="line">    shadowColor: ...,</span><br><span class="line">    shadowOffsetX: 0,</span><br><span class="line">    shadowOffsetY: 0,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="categoryAxis（类目轴）"><a href="#categoryAxis（类目轴）" class="headerlink" title="categoryAxis（类目轴）"></a>categoryAxis（类目轴）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">categoryAxis: &#123;</span><br><span class="line">    show: <span class="literal">true</span>,             // 是否显示 x 轴</span><br><span class="line">    gridIndex: 0,           // x轴所在的grid的索引</span><br><span class="line">    position: ...,          // x轴的位置 <span class="string">'top'</span>|<span class="string">'bootom'</span></span><br><span class="line">    offset: 0,              // x轴相对于默认位置的偏移</span><br><span class="line">    // **在相同的`position`上有多个x轴的时候起作用**</span><br><span class="line">    name: ...,              // 坐标轴名称</span><br><span class="line">    nameLocation: <span class="string">'end'</span>,    // 坐标轴名称显示位置</span><br><span class="line">                            // <span class="string">'start'</span>|<span class="string">'middle'</span>或<span class="string">'center'</span>|<span class="string">'end'</span></span><br><span class="line">    nameTextStyle: &#123;...&#125;,   // 坐标轴名称的文字样式</span><br><span class="line">    nameGap: 15,            // 坐标轴名称与轴线之间的距离</span><br><span class="line">    nameRotate: null,       // 坐标轴名字旋转，角度值</span><br><span class="line">    inverse: <span class="literal">false</span>,         // 是否反向坐标轴</span><br><span class="line">    boundaryGap: ...,       // 坐标轴两边留白</span><br><span class="line">                            // 类目轴 <span class="string">'true'</span>|<span class="string">'false'</span></span><br><span class="line">                            // 非类目轴 数组[<span class="string">"20%"</span>, <span class="string">"20%"</span>]，数组值可以为百分比或数值</span><br><span class="line">    min: null,              </span><br><span class="line">    /** 坐标轴刻度最小值</span><br><span class="line">        可以设置成特殊值 <span class="string">'dataMin'</span>，此时取数据在该轴上的最小值作为最小刻度。</span><br><span class="line">        当设置成 <span class="keyword">function</span> 形式时，可以根据计算得出数据的最小值来设定坐标轴的最小值                    </span><br><span class="line">    **/</span><br><span class="line">    max: null,              // 坐标轴刻度最大值 同理 最小值</span><br><span class="line">    scale: <span class="literal">false</span>,           // 数值轴有效，是否脱离0值比例</span><br><span class="line">    splitNumber: 5,         // 坐标轴分割段数（预估值）类目轴无效</span><br><span class="line">    minInterval: 0,         // 自动计算坐标轴最小间隔 设置成1保证坐标轴分割刻度显示成整数</span><br><span class="line">    maxInterval: ...,       // 自动计算坐标轴最大间隔</span><br><span class="line">    interval: ...,          // 强制设置坐标轴分割间隔</span><br><span class="line">    logBase: 10,            // 对数轴的底数，只在对数轴中（<span class="built_in">type</span>: <span class="string">'log'</span>）有效</span><br><span class="line">    silent: <span class="literal">false</span>,          // 坐标轴是否是静态无法交互</span><br><span class="line">    triggerEvent: <span class="literal">false</span>,    // 坐标轴的标签是否响应和触发鼠标事件，默认不响应</span><br><span class="line">    axisLine: &#123;             // 坐标轴轴线相关设置</span><br><span class="line">        show: <span class="literal">true</span>,         // 是否显示坐标轴轴线</span><br><span class="line">        onZero: <span class="literal">true</span>,       // X轴或Y轴的轴线是否在另一个轴的<span class="string">'0'</span>刻度上，只有在另一个轴为数值轴且包含<span class="string">'0'</span>刻度时有效</span><br><span class="line">        onZeroAxisIndex: ...,   // 当有双轴时，指定在哪个轴的<span class="string">'0'</span>刻度上</span><br><span class="line">        symbol: <span class="string">'none'</span>,         // 轴线两边的箭头 [<span class="string">'none'</span>, <span class="string">'arrow'</span>]</span><br><span class="line">        symbolSize: [10, 15],   // 轴线两边的箭头的大小，[<span class="string">'垂直'</span>,<span class="string">'水平'</span>]</span><br><span class="line">        symbolOffset: [0, 0],   // 轴线两边的箭头的偏移</span><br><span class="line">    &#125;,</span><br><span class="line">    axisTick: &#123;                 // 坐标轴刻度相关设置</span><br><span class="line">        show: <span class="literal">true</span>,         </span><br><span class="line">        alignWithLabel: <span class="literal">false</span>,  // 类目轴中<span class="string">'boundaryGap'</span>为<span class="string">'true'</span>时有效，保证刻度线和标签对齐</span><br><span class="line">        interval: <span class="string">'auto'</span>,   // 坐标轴刻度的显示间隔，在类目轴中有效</span><br><span class="line">        inside: <span class="literal">false</span>,      // 坐标轴刻度是否朝内，默认朝外</span><br><span class="line">        length: 5,          // 坐标轴刻度的长度</span><br><span class="line">        lineStyle: &#123;</span><br><span class="line">            color: ...,</span><br><span class="line">            width: 1,</span><br><span class="line">            <span class="built_in">type</span>: <span class="string">'solid'</span>,      // 坐标轴刻度线的类型。</span><br><span class="line">                                // <span class="string">'solid'</span>|<span class="string">'dashed'</span>|<span class="string">'dotted'</span></span><br><span class="line">            shadowBlur: ...,</span><br><span class="line">            shadowColor: ...,</span><br><span class="line">            shadowOffsetX: 0,</span><br><span class="line">            shadowOffsetY: 0,</span><br><span class="line">            opacity: ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    axisLabel: &#123;...&#125;,       // 坐标轴刻度标签的相关设置</span><br><span class="line">    splitLine: &#123;            // 坐标轴在<span class="string">'grid'</span>区域中的分隔线</span><br><span class="line">        show: <span class="literal">true</span>,</span><br><span class="line">        interval: <span class="string">'auto'</span>,</span><br><span class="line">        lineStyle: &#123;...&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    splitArea: &#123;            // 分隔区域的样式设置</span><br><span class="line">        interval: <span class="string">'auto'</span>,</span><br><span class="line">        show: <span class="literal">false</span>,        // 是否显示分隔区域</span><br><span class="line">        areaStyle: &#123;</span><br><span class="line">            // 分隔区域颜色。分隔区域会按数组中颜色的顺序依次循环设置颜色</span><br><span class="line">            color: [<span class="string">'rgba(250,250,250,0.3)'</span>,<span class="string">'rgba(200,200,200,0.3)'</span>],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data: [&#123;...&#125;],</span><br><span class="line">    axisPointer: &#123;...&#125;,</span><br><span class="line">    zlevel: 0,</span><br><span class="line">    z: 0,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="valueAxis（数值轴）、radiusAxis（极坐标系的径向轴）、angleAxis-极坐标系的角度轴"><a href="#valueAxis（数值轴）、radiusAxis（极坐标系的径向轴）、angleAxis-极坐标系的角度轴" class="headerlink" title="valueAxis（数值轴）、radiusAxis（极坐标系的径向轴）、angleAxis(极坐标系的角度轴)"></a>valueAxis（数值轴）、radiusAxis（极坐标系的径向轴）、angleAxis(极坐标系的角度轴)</h3><p>数值轴、极坐标系的径向轴、极坐标系的角度轴的配置，基本与类目轴一致，可参考’categoryAxis’</p><h3 id="line（折线图）"><a href="#line（折线图）" class="headerlink" title="line（折线图）"></a>line（折线图）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">line: &#123;</span><br><span class="line">    name: ...,</span><br><span class="line">    coordinateSystem: <span class="string">'cartesian2d'</span>,        // 坐标系</span><br><span class="line">    xAxisIndex: 0,</span><br><span class="line">    yAxisIndex: 0,</span><br><span class="line">    polarIndex: 0,</span><br><span class="line">    symbol: <span class="string">'emptyCircle'</span>,      // 标记的图形 <span class="string">'circle'</span>|<span class="string">'rect'</span>|<span class="string">'roundRect'</span>|<span class="string">'triangle'</span>|<span class="string">'diamond'</span>|<span class="string">'pin'</span>|<span class="string">'arrow'</span>|<span class="string">'none'</span>，可通过<span class="string">'image://url'</span>设为图片，其中<span class="string">'URL'</span>为图片链接</span><br><span class="line">    symbolSize: 4,              // 标记的大小</span><br><span class="line">    symbolRotate: ...,          // 标记的旋转角度</span><br><span class="line">    symbolKeepAspect: <span class="literal">false</span>,    // 是否在缩放时保持该图形的长宽比(仅图片)</span><br><span class="line">    symbolOffset: [0, 0],       // 标记相对于原本位置的偏移</span><br><span class="line">    showSymbol: <span class="literal">true</span>,           // 是否显示<span class="string">'symbol'</span></span><br><span class="line">    showAllSymbol: <span class="string">'auto'</span>,      </span><br><span class="line">    hoverAnimation: <span class="literal">true</span>,       // 是否开启<span class="string">'hover'</span>在拐点标志上的提示动画效果</span><br><span class="line">    legendHoverLink: <span class="literal">true</span>,      // 是否启用图例<span class="string">'hover'</span>时的联动高亮</span><br><span class="line">    stack: null,                // 数据堆叠，同个类目轴上系列配置相同的<span class="string">'stack'</span>值后，后一个系列的值会在前一个系列的值上相加</span><br><span class="line">    cursor: <span class="string">'pointer'</span>,</span><br><span class="line">    connectNulls: <span class="literal">false</span>,        // 是否连接空数据</span><br><span class="line">    clipOverflow: <span class="literal">true</span>,         // 是否对超出部分裁剪，默认裁剪</span><br><span class="line">    step: <span class="literal">false</span>,                // 是否是阶梯线图。可设为<span class="string">'true'</span>显示成阶梯线图</span><br><span class="line">    label: &#123;...&#125;,               // 图形上的文本标签，参考<span class="string">'title'</span></span><br><span class="line">    itemStyle: &#123;...&#125;,           // 折线拐点标志的样式</span><br><span class="line">    lineStyle: &#123;...&#125;,           // 线条样式</span><br><span class="line">    areaStyle: &#123;...&#125;,           // 区域填充样式</span><br><span class="line">    emphasis: &#123;                 // 图形的高亮样式</span><br><span class="line">        label: &#123;...&#125;,</span><br><span class="line">        itemStyle: &#123;...&#125;,</span><br><span class="line">    &#125;,            </span><br><span class="line">    smooth: <span class="literal">false</span>,              // 是否平滑曲线显示</span><br><span class="line">    smoothMonotone: ...,        // 折线平滑后是否在一个维度上保持单调性</span><br><span class="line">    sampling: ...,  </span><br><span class="line">    dimensions: [...],</span><br><span class="line">    encode: &#123;...&#125;,</span><br><span class="line">    seriesLayoutBy: <span class="string">'column'</span>,</span><br><span class="line">    datasetIndex: 0,</span><br><span class="line">    data: [&#123;</span><br><span class="line">        name: ...,</span><br><span class="line">        value: ...,</span><br><span class="line">        symbol: <span class="string">'circle'</span>,</span><br><span class="line">        symbolSize: 4,</span><br><span class="line">        symbolRotate: ...,</span><br><span class="line">        symbolKeepAspect: <span class="literal">false</span>,</span><br><span class="line">        symbolOffset: [0, 0],</span><br><span class="line">        label: &#123;...&#125;,</span><br><span class="line">        itemStyle: &#123;...&#125;,</span><br><span class="line">        emphasis: &#123;...&#125;,</span><br><span class="line">        tooltip: &#123;...&#125;,</span><br><span class="line">    &#125;],</span><br><span class="line">    markPoint: &#123;...&#125;,           // 图表标注</span><br><span class="line">    markLine: &#123;...&#125;,            // 图表标线</span><br><span class="line">    markArea: &#123;...&#125;,            // 图表标域，常用于标记图表中某个范围的数据</span><br><span class="line">    zlevel: 0,</span><br><span class="line">    z: 2,</span><br><span class="line">    silent: <span class="literal">false</span>,</span><br><span class="line">    animation: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bar（柱形图）"><a href="#bar（柱形图）" class="headerlink" title="bar（柱形图）"></a>bar（柱形图）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">bar: &#123;</span><br><span class="line">    name: ...,</span><br><span class="line">    legendHoverLink: <span class="literal">true</span>,</span><br><span class="line">    coordinateSystem: <span class="string">'cartesian2d'</span>,</span><br><span class="line">    xAxisIndex: 0,</span><br><span class="line">    yAxisIndex: 0,</span><br><span class="line">    label: &#123;...&#125;,</span><br><span class="line">    itemStyle: &#123;...&#125;,</span><br><span class="line">    emphasis: &#123;...&#125;,</span><br><span class="line">    stack: null,</span><br><span class="line">    cursor: <span class="string">'pointer'</span>,</span><br><span class="line">    barWidth: 自适应,                    // 柱条宽度</span><br><span class="line">    barMaxWidth: 自适应,                 // 柱条最大宽度</span><br><span class="line">    barMinHeight: 0,                    // 柱条最小高度</span><br><span class="line">    barGap: 30%,                        // 柱条间距 想要两柱子重叠，可设为<span class="string">'-100%'</span></span><br><span class="line">    barCategoryGap: <span class="string">'20%'</span>,              // 同一系列的柱间距</span><br><span class="line">    large: <span class="literal">false</span>,                       // 是否开启大数据量优化</span><br><span class="line">    largeThreshold: 400,                // 开启绘制优化的阈值</span><br><span class="line">    progressive: 5000,                  // 渐进式渲染时，每一帧绘制图形数量</span><br><span class="line">    progressiveThreshold: 3000,         // 启用渐进式渲染的图形数量阈值</span><br><span class="line">    progressiveChunkMode: mod,          // 分片的方式：</span><br><span class="line">                                        // <span class="string">'sequential'</span>|<span class="string">'mod'</span></span><br><span class="line">    dimensions: [...],</span><br><span class="line">    encode: &#123;...&#125;,                      // 可定义<span class="string">'data'</span>的某个维度被编码</span><br><span class="line">    seriesLayoutBy: <span class="string">'column'</span>,</span><br><span class="line">    datasetIndex: 0,</span><br><span class="line">    data: [&#123;</span><br><span class="line">        name: ...,</span><br><span class="line">        value: ...,</span><br><span class="line">        label: &#123;...&#125;,                   // 单个柱条文本样式设置</span><br><span class="line">        itemStyle: &#123;...&#125;,</span><br><span class="line">        emphasis: &#123;...&#125;,</span><br><span class="line">        tooltip: &#123;...&#125;,</span><br><span class="line">    &#125;],</span><br><span class="line">    markPoint: &#123;...&#125;,</span><br><span class="line">    markLine: &#123;...&#125;,</span><br><span class="line">    markArea: &#123;...&#125;,</span><br><span class="line">    zlevel: 0,</span><br><span class="line">    z: 2,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pie（饼图）"><a href="#pie（饼图）" class="headerlink" title="pie（饼图）"></a>pie（饼图）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pie: &#123;</span><br><span class="line">    legendHoverLink: <span class="literal">true</span>,</span><br><span class="line">    hoverAnimation: <span class="literal">true</span>,</span><br><span class="line">    hoverOffset: 10,                // 高亮扇区的偏移距离</span><br><span class="line">    selectedMode: <span class="literal">false</span>,            // 选中模式，表示是否支持多个选中</span><br><span class="line">    selectedOffset: 10,             // 选中扇区的偏移距离</span><br><span class="line">    clockwise: <span class="literal">true</span>,                // 饼图的扇区是否是顺时针排布</span><br><span class="line">    startAngle: 90,                 // 起始角度</span><br><span class="line">    minAngle: 0,                    // 最小的扇区角度</span><br><span class="line">    minShowLabelAngle: 0,           // 小于该角度的扇区，不显示标签</span><br><span class="line">    roseType: <span class="literal">false</span>,                // 是否展示成南丁格尔图，通过半径区分数据大小</span><br><span class="line">                                    // <span class="string">'radius'</span> | <span class="string">'area'</span></span><br><span class="line">    avoidLabelOverlap: <span class="literal">true</span>,        // 是否启用防止标签重叠策略</span><br><span class="line">    stillShowZeroSum: <span class="literal">true</span>,         // 是否在数据和为0的时候不显示扇区</span><br><span class="line">    cursor: <span class="string">'pointer'</span>,</span><br><span class="line">    label: &#123;...&#125;,       // 饼图图形上的文本标签，可用于说明图形的一些数据信息</span><br><span class="line">    labelLine: &#123;        // 标签的视觉引导线样式</span><br><span class="line">        show: ...,</span><br><span class="line">        length: ...,    // 视觉引导线第一段的长度</span><br><span class="line">        length2: ...,   // 视觉引导线第二段的长度</span><br><span class="line">        smooth: <span class="literal">false</span>,</span><br><span class="line">        lineStyle: &#123;...&#125;,</span><br><span class="line">    &#125;,   </span><br><span class="line">    itemStyle: &#123;...&#125;,       // 图形样式</span><br><span class="line">    emphasis: &#123;...&#125;,</span><br><span class="line">    zlevel: 0,</span><br><span class="line">    z: 2,</span><br><span class="line">    center: [<span class="string">'50%'</span>, <span class="string">'50%'</span>],</span><br><span class="line">    radius: [0, <span class="string">'75%'</span>],             // 饼图的半径</span><br><span class="line">    seriesLayoutBy: <span class="string">'column'</span>,</span><br><span class="line">    datasetIndex: 0,</span><br><span class="line">    data: [&#123;...&#125;],</span><br><span class="line">    markPoint: &#123;...&#125;,</span><br><span class="line">    markLine: &#123;...&#125;,</span><br><span class="line">    markArea: &#123;...&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="polar（极坐标）"><a href="#polar（极坐标）" class="headerlink" title="polar（极坐标）"></a>polar（极坐标）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">polar: &#123;</span><br><span class="line">    zlevel: 0,</span><br><span class="line">    z: 2,</span><br><span class="line">    // 极坐标系的中心（圆心）坐标，数组的第一项是横坐标，第二项是纵坐标。</span><br><span class="line">    // 支持设置成百分比，第一项是相对于容器宽度，第二项是相对于容器高度</span><br><span class="line">    center: [<span class="string">'50%'</span>, <span class="string">'50%'</span>],</span><br><span class="line">    /** 极坐标系的半径。可以为如下类型：</span><br><span class="line">        number：直接指定外半径值。</span><br><span class="line">        string：如，<span class="string">'20%'</span>，表示外半径为可视区尺寸（容器高宽中较小一项）的20%长度</span><br><span class="line">        Array.&lt;number|string&gt;：数组的第一项是内半径，第二项是外半径</span><br><span class="line">    **/</span><br><span class="line">    radius: ...,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="radar（雷达坐标系）"><a href="#radar（雷达坐标系）" class="headerlink" title="radar（雷达坐标系）"></a>radar（雷达坐标系）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">radar: &#123;</span><br><span class="line">    zlevel: 0,</span><br><span class="line">    z: 2,</span><br><span class="line">    center: [<span class="string">'50%'</span>, <span class="string">'50%'</span>],</span><br><span class="line">    radius: 75%,</span><br><span class="line">    startAngle: 90,</span><br><span class="line">    name: &#123;...&#125;,    // 雷达图每个指示器名称的配置项 可参考title中textStyle</span><br><span class="line">    nameGap: 15,</span><br><span class="line">    splitNumber: 5,     </span><br><span class="line">    shape: <span class="string">'polygon'</span>,   // 雷达绘制类型 支持<span class="string">'polygon'</span> 和 <span class="string">'circle'</span></span><br><span class="line">    scale: <span class="literal">false</span>,</span><br><span class="line">    silent: <span class="literal">false</span>,</span><br><span class="line">    triggerEvent: <span class="literal">false</span>,</span><br><span class="line">    axisLine: &#123;</span><br><span class="line">        show: <span class="literal">true</span>,</span><br><span class="line">        symbol: <span class="string">'none'</span>,</span><br><span class="line">        symbolSize: [10, 15],</span><br><span class="line">        symbolOffset: [0, 0],</span><br><span class="line">        lineStyle: &#123;...&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    splitLine: &#123;</span><br><span class="line">        show: <span class="literal">true</span>,</span><br><span class="line">        lineStyle: &#123;...&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    splitArea: &#123;</span><br><span class="line">        show: <span class="literal">true</span>,</span><br><span class="line">        areaStyle: &#123;...&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    indicator: [    // 雷达图的指示器，用来指定雷达图中的多个变量（维度）</span><br><span class="line">                    // 类似于 直角坐标系中的 data</span><br><span class="line">        &#123;</span><br><span class="line">            name: ...,</span><br><span class="line">            max: ...,</span><br><span class="line">            min: ...,</span><br><span class="line">            color: ...,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>整理的目的不是记忆，把配置表背下来毫无意义，仅是为了更加好的查询各项图表配置。整理后，对其有了整体认识，这算是一个意外的收获吧。<br>同时将该文收录在个人博客上<a href="lostimever.github.io">lostimever.github.io</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://echarts.baidu.com/option.html" target="_blank" rel="noopener">Echarts官网</a></li><li><a href="https://www.w3cschool.cn/echarts_tutorial" target="_blank" rel="noopener">W3Cschool</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于版本v4.x&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;吐血整理。&lt;br&gt;Echarts的各种配置真的是眼花缭乱，第一次使用的时候，内心真的是崩溃啊，看到就害怕。最近开始搞项目了，面对一堆图表，更是无所适从，才萌生了整理echarts配置的想法。仅仅整理了常用的，后续如果有需求，会进行补充。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 Hexo 和 GitHub Pages 搭建简单的个人博客</title>
    <link href="http://yoursite.com/2019/05/31/build-your-blog/"/>
    <id>http://yoursite.com/2019/05/31/build-your-blog/</id>
    <published>2019-05-31T13:57:27.000Z</published>
    <updated>2019-06-06T07:40:47.293Z</updated>
    
    <content type="html"><![CDATA[<p>闲来无事，趁着摸鱼时间，使用<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>和 <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>搭建出最简单的个人博客。<br>毕竟磨蹭了很久了，苦于自己的技术水平不够，加上日常懒癌发作，终终终于找到了最简单又免费的方式来搭建个人博客，顺带撸出自己的第一个博文。<br>下面就让我们愉（tong）快（ku）的开始吧！</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>先安装好以下应用程序：</p><ul><li><a href="https://nodejs.org/zh-cn" target="_blank" rel="noopener">nodeJs</a></li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><p>安装过程不再赘述，可自行度娘，安装完毕后，使用<code>npm</code>即可完成Hexo的安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><p>注册并登陆好 GitHub 账户</p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="创建你的项目"><a href="#创建你的项目" class="headerlink" title="创建你的项目"></a>创建你的项目</h3><p>在控制台执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br></pre></td></tr></table></figure><p>如果你的电脑安装了yarn，执行该脚本后，会自动为你安装依赖（即执行<code>yarn install</code>），否则你还需执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>至此，你的本地博客已经建立成功，只需要运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>并在浏览器上输入地址 <a href="localhost:4000" target="_blank" rel="noopener">localhost:4000</a> 便可预览初始化的博客内容。</p><h2 id="GitHub-1"><a href="#GitHub-1" class="headerlink" title="GitHub"></a>GitHub</h2><h3 id="创建自己的仓库"><a href="#创建自己的仓库" class="headerlink" title="创建自己的仓库"></a>创建自己的仓库</h3><p>进入你的 GitHub 主页，<a href="https://github.com/new" target="_blank" rel="noopener">创建一个新的repository</a>。并输入对应的Repository name，请注意：<strong><font color="#DD3B38">必须保持格式<code>&lt;username&gt;.github.io</code>，其中<code>&lt;username&gt;</code>替换成你的 GitHub 账户名</font></strong>，例如：lostimever.github.io</p><img src="/2019/05/31/build-your-blog/create.jpg" title="build-your-blog"><p>点击<strong>Create repository</strong>即可。</p><h2 id="将本地博客上传至GitHub"><a href="#将本地博客上传至GitHub" class="headerlink" title="将本地博客上传至GitHub"></a>将本地博客上传至GitHub</h2><h3 id="修改本地文件"><a href="#修改本地文件" class="headerlink" title="修改本地文件"></a>修改本地文件</h3><p>打开之前新建的hexo文件夹，在根目录下有个<font color="#DD3B38">_config.yml</font>文件，用文本编辑器打开，在最下面找到deploy，修改为：<br><code>deploy:  type: git  repository: http://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git  branch: master</code></p><p>将<font color="#DD3B38"><code>&lt;username&gt;</code>替换成你的 GitHub 账户名，并保存即可</font>。</p><h3 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h3><p>在命令行中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>当命令行中显示：<br><code>INFO  Deploy done: git</code><br>说明部署成功。打开浏览器在地址栏中输入lostimever.github.io(将lostimever改成自己的)，就能看见自己的博客了，别人也可以访问。</p><h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><h3 id="报错：ERROR-Deployer-not-found-git"><a href="#报错：ERROR-Deployer-not-found-git" class="headerlink" title="报错：ERROR Deployer not found: git"></a>报错：<code>ERROR Deployer not found: git</code></h3><p>在命令行中输入<br><code>npm install hexo-deployer-git --save</code><br>或<code>yarn add hexo-deployer-git</code><br>重新执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>*注意： 笔者安装的hexo的版本为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo: 3.8.0</span><br><span class="line">hexo-cli: 2.0.0</span><br></pre></td></tr></table></figure><p>不同的版本之间的配置可能有些许不同，注意查看自己的版本。</p><h2 id="写博客文章"><a href="#写博客文章" class="headerlink" title="写博客文章"></a>写博客文章</h2><h3 id="创建新的文章"><a href="#创建新的文章" class="headerlink" title="创建新的文章"></a>创建新的文章</h3><p>在命令行中输入：<code>hexo new “name”</code>（将name替换成你的文章的标题），<br>然后在<font color="#DD3B38">source/_posts/</font>里就能看到名为<code>name.md</code>的文件了，现在就可以愉快的写博（tu）客（cao）啦。<br>也可以直接在<font color="#DD3B38">source/_posts/</font>里直接新建一个名为<code>name.md</code>的文件，注意开头需加入以下内容：<br> <code>---   title: name   date: 2019-05-31 21:57:27   tags: ---</code></p><h3 id="文章中如何插入图片"><a href="#文章中如何插入图片" class="headerlink" title="文章中如何插入图片"></a>文章中如何插入图片</h3><p>Hexo插入图片的方式很多，这里只介绍一种：将图片放在当前文章的目录中。文章的目录可以通过配置<code>_config.yml</code>来生成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>将<code>_config.yml</code>文件中的配置项<code>post_asset_folder</code>设为<code>true</code>后，执行命令<code>$ hexo new &quot;name&quot;</code>，在<code>source/_posts</code>中会生成文章<code>name.md</code>和同名文件夹<code>name</code>。将图片资源放在<code>name</code>中，文章就可以引用图片资源了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img image.jpg document name %&#125;</span><br></pre></td></tr></table></figure><h2 id="发表文章"><a href="#发表文章" class="headerlink" title="发表文章"></a>发表文章</h2><p>写好文章并保存后，重复 <strong>开始部署</strong> 中的操作即可。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>建博一时爽，更新如难产。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">hexo官网</a></li><li><a href="https://pages.github.com/" target="_blank" rel="noopener">Github pages</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闲来无事，趁着摸鱼时间，使用&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;和 &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;搭建出最简单的个人博客。&lt;br&gt;毕竟磨蹭了很久了，苦于自己的技术水平不够，加上日常懒癌发作，终终终于找到了最简单又免费的方式来搭建个人博客，顺带撸出自己的第一个博文。&lt;br&gt;下面就让我们愉（tong）快（ku）的开始吧！&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
